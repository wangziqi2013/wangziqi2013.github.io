---
layout: paper-summary
title:  "NVM Duet: Unified Working Memory and Persistent Store Architecture"
date:   2019-11-03 21:22:00 -0500
categories: paper
paper_title: "NVM Duet: Unified Working Memory and Persistent Store Architecture"
paper_link: https://dl.acm.org/citation.cfm?id=2541957
paper_keyword: NVM; NVM Duet
paper_year: ASPLOS 2014
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes NVM Duet, a software-hardware co-design that enables better write performance within NVM by using
more flexible scheduling and by taking advantage of the physical property. The discussion is based on byte addressable 
Phase Change Memory (PCM) installed to the memory bus, which can be accessed in cache line granularity via load 
and store instructions. The paper identifies two problems that result in prolonged write latency in current NVM architectures. 
The first problem is that writes are not always scheduled in an optimal manner given the hardware primitive for implementing
software persistence barriers. At the time of writing this paper, Intel has proposed using clflush (and later an optimized
form, clwb, is added to the ISA), sfence and pcommit (now deprecated) to force data to be written back into the NVM.
This persistence barrier serializes all store instructions before the barrier before instructions issued after the barrier,
i.e. the latter group must wait for the former to be fully committed into memory before they are. This results 
in suboptimal scheduling of memory operations given that bank-level parallelism exists and can support multiple active 
writes, while it is not always possible to find a write to feed a bank in the current epoch due to persistence barrier. 
In practice, these barriers will not only serialize instructions that we intend to serialize, but also they enforce the 
ordering on memory instructions that do not have any ordering requirement, e.g. memory instructions from another hardware 
thread, anothe core, or to memory locations that are not necessarily persistent such as local scratch space and the stack. 
The second problem is that most workloads do not require all stores to be persistent. For those "volatile" stores, it is 
unnecessary for them to be retained for days or even months even if the address space is mapped to the NVM. It is a 
waste of write latency and power to write all data with the same retention, while some of them can be safely lost on
a power down without corrupting anything.

This paper proposes adding a bit vector, called a AllocMap to the memory controller to record which memory page requires 
data persistence, and which does not. For a 16GB PCM chip, the total space for AllocMap is just 512KB, which can be stored 
easily by the on-chip SRAM. Initially, all bits are set to "0". On an operating system page mapping, the user specifies 
whether a certain page should be mapped as persistent memory, which requires strong ordering indicated by memory barriers,
or the page should be mapped as working memory, which just provides run-time storage of volatile data, and might be 
reset or corrupted after a power loss. In the mmap() system call, the OS uses MMIO to communicate with the memory controller,
and sets the corresponding 4KB bit to "1" if it is demanded by user to map it as working memory.
