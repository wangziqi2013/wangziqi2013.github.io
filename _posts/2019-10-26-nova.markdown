---
layout: paper-summary
title:  "NOVA: A Log-Strictured File System for Hybrid Volatile/Non-volatile Main Memories"
date:   2019-10-26 23:39:00 -0500
categories: paper
paper_title: "NOVA: A Log-Strictured File System for Hybrid Volatile/Non-volatile Main Memories"
paper_link: https://www.usenix.org/node/194455
paper_keyword: NVM; File System; NOVA; Log-Structured
paper_year: FAST 2016
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper presents NOVA, a file system optimized for NVM which provides strong atomicity guarantees. In order for a 
file system operation to be atomic, either all of its sub-operations are committed to persistent storage, or none of them is
committed. This is especially true when the file system suffers from a crash or failure, in which case the persistent
storage may only contain partially updates states, due to the fact that page buffers maintained by the OS or hardware 
caches can evict pages back to the storage at unpredicable times.

As a result, several techniques are implemented to prevent these partial updates from corrupting the state of the file 
system, typically via a post-crash recovery process. The first technique is called journaling, in which all modifications
to the file system, including metadata and data, are first written to a persistent journal, and then written in-place.
A write ordering is enforced between the commit of the journal and the actual update of file system states to ensure 
that these operations can always be replayed after the journal has been committed. In the post-crash recovery process, 
if the journal is found to have committed, it will be replayed. The journal can only be removed after all dirty
pages are flushed to the disk. The problem of journaling is that it doubles I/O traffic to the disk, since both the journal
and the data need to be persisted. The second technique is shadow paging, which is commonly used in tree-structured file
systems. In such a file system, it is assumed that directories and files are organized into a search tree, such that there
is only one pointer to a page. When a page is to be updated, it is first duplicated by copying all contents of the 
page to another page, and all modifications are performed on the new page. Non-atomic modifications to the page are
committed by an atomic compare-and-swap to the parent of the page. In this scheme, any change made on any level
of the tree will propagate to the root, since when we modify the pointer on the parent node, a new copy of the parent
node is also created and then swapped into the grandparent node. This cascading effect unnecessary memory traffic and 
can be expensive. The last technique is log-structured file system, in which all data and metadata are maintained in
an append-only manner. Log-structured file systems can commit changes atomically by first appending the changes at the 
end of the log, followed by an atomic swap of the log tail pointer. This scheme, however, suffers from garbage collection
problem, since obsolete data and metadata will need to be constantly removed to reclaim storage. In the case where 
no continuous storage can be reclaimed, live data needs to be moved around, which also causes unnecessary traffic.

NOVA features log-structured atomic commit of both data and metadata changes, without the cost of expensive page-level 
journaling, shadow paging, or garbage collection. This is achieved by adapting log-structured updates to provide the ideal 
semantics of atomic operations, while not maintaining the log as a physically sequential object on the disk. This
combination is valid for NVM, due to the fact that NVM writes are less sensitive to the sequentiality of data, while
on a spinning disk or SSD it is best practice to make sequential write the common case. 

Based on the physical location, NOVA metadata is divided into two parts: An in-memory part which supports efficient 
lookup but provides no atomic support, and a log-structured NVM part which is difficult to search with (have to scan 
the log), but supports efficient atomic update. The in-memory part is constructed from the NVM part lazily during normal
operations. When the file system is first mounted, only essential metadata is initialized from the super block. As 
user applications issue file accesses, the in-memory representation of the inode, directory, memory allocator, etc. are 
initialized by scanning the log and applying all changes.

NOVA organizes its inode table similar to a conventional file system. Instead of appending all inode modifications into
the master log as in log-structured file systems, NOVA maintains a central inode table at the beginning of the address
space, and partitions the inode table across cores to make parallel inode allocation and scanning possible. An inode in
NOVA consists of two pointers, a log head pointer and a log tail pointer. Logs are maintained in a per-inode manner, in
the form of linked lists of log blocks. These log blocks do not necessarily occupy continuous storage on the NVM. The log 
head pointer points to the first log block of the inode, while the log tail pointer points to the last committed state of 
the inode. States can be committed onto an inode by atomically moving the log tail pointer. The remaining part of the 
address space is maintained as a heap, from which log blocks and data pages can be allocated in a non-log-structured manner. 
Precise allocator states are maintained in the main memory as a block pool, which is persisted back to the NVM on a normal 
shutdown. On a failure, the persistent version of allocator state might be inconsistent, in which case we need to reconstruct 
the state by scanning all inodes and marking pages used by these inodes as active. After the scan, pages that are unmarked 
are added to the pool.