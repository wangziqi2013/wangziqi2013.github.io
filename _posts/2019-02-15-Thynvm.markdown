---
layout: paper-summary
title:  "ThyNVM: Enabling Software-Transparent Crash Consistency in Persistent Memory Systems"
date:   2019-02-15 20:16:00 -0500
categories: paper
paper_title: "ThyNVM: Enabling Software-Transparent Crash Consistency in Persistent Memory Systems"
paper_link: https://dl.acm.org/citation.cfm?doid=2830772.2830802
paper_keyword: NVM; Redo; Epoch; Checkpointing
paper_year: MICRO 2015
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---  

This paper proposes ThyNVM, a hardware checkpointing mechanism that uses multi-granularity multiversioning. Before ThyNVM,
there are two ways of achieving continuous checkpointing: Logging and shadow page. Both approaches have inherent problems
that limit their efficiency. For logging, the granularity that data are copied into the log plays an important role in the 
performance of the system. If log entries are generated on a fine granularity, then metadata overhead will be a few times
larger than logged data itself, since for each log entry, we need to store the transaction ID, log sequence number, and 
some other auxiliary information. If, on the other hand, the granularity is large, the overhead of copying data into log
entries will dominate execution time. The problem aggravates if data items are only written sparsely, in which case space 
is also wasted, because most part of the data copied into the log entry is unnecessary. Similar problems can be observed 
with shadow paging: On every memory update, if the page of the updated location has not been buffered by the DRAM, a 
page copy is made to transfer the page from NVM to DRAM, and all future writes to the NVM will be buffered by the shadow
page until the next checkpoint, during which the dirty page is written back. This approach, however, is sub-optimal if 
the page is only written a few times before the end of the current epoch. Memory bandwidth as well as idle cycles are wasted
due to the two data transfer between the shadow page and NVM.

No existing scheme works well under all workloads and all write patterns. Some schemes are particularly good for some 
workloads, and bad on others. This paper made the following two observations. First, if a location is only written
sparsely (i.e. memory writes have little spatial locality around that location), the modification should be written 
directly into the NVM. This scheme avoids wasting memory bandwidth on unnecessary data transfer as well as wasting 
NVM storage by storing excessive metadata in log entries. Since only a few writes will be directly performed on NVM,
the increase of write latency is expected to be minimal. Second, if a location is modified frequently and has good spatial
locality, it should be buffered by the DRAM in page granularity to prevent repeated writes to the NVM and to improve 
the latency of write operations when conducted on the buffered page.

ThyNVM adopts a multiversioning scheme for supporting flexible granularity in order to leverage the above two observations.
The system is assumed to be directly operating on NVM as main memory. DRAM is also installed as buffers for data in the active
epoch as we will describe below. System execution is divided into epoches, which are the basic units of checkpointing 
and recovery. At the end of each epoch, the system execution is interrupted, and the system state is dumped and stored on
the NVM. On failure, it is guaranteed that the system state can be restored to a previous epoch, after which normal execution
resumes and it appears as if no failure had ever happened. The memory controller is aware of the existence of NVM and DRAM,
and can access both using the device ID and physical address on the drvice. The memory controller provides the abstraction
of a unified address space to upper levels in the memory hierarchy, such that the semantics of existing programs compiled for
DRAM do not change during normal execution (except that some operations may take longer to complete if they operate on NVM). 
At system startup time, the operating system probes the mapping information of the physical address space, and divice the 
address space accordingly into regions