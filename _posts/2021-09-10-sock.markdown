---
layout: paper-summary
title:  "SOCK: Rapid Task Provisioning with Serverless-Optimized Containers"
date:   2021-09-10 19:39:00 -0500
categories: paper
paper_title: "SOCK: Rapid Task Provisioning with Serverless-Optimized Containers"
paper_link: https://dl.acm.org/doi/10.5555/3277355.3277362
paper_keyword: Microservice; Serverless; OS; Process Template; SOCK
paper_year: USENIX ATC 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents SOCK, a customized container framework for reducing cold start latency of serverless functions.
The paper is motivated by the observation that both language runtime initialization, such as library import, and 
container initialization will incur long startup latency, which are jointly called the "cold start latency".
This paper addresses cold start latency using a series of techniques, including a customized "lean" container that
avoids long latency system calls and relaxes certain isolation requirements not needed for serverless, 
a local cache of commonly used Python libraries, and using fork() to clone already initialized Zygote containers.
The paper also presents a series of performance evaluations of Linux systems calls related to container virtualization, 
as well as various engineering details that have different performance trade-offs.

To reduce container startup time, the paper argues that container implementations for general purposes, such as 
Docker, provides full and the strongest isolation. Serverless functions, however, do not always require all the 
features provides by these containers, since serverless functions are typically small, only perform simple tasks, and
do not use many of the OS features (e.g., static port assignment). 
The paper makes three important observations on container-related system calls, which we discuss in details as follows.

First, it is sufficient to achieve file system virtualization with bind mounting and chroot(). The former is just a 
special form of mount() system call that redirects the access to the destination path to the source path.
It behaves like a mount(), because it still inserts an entry into the mount point table. 
chroot() simply moves the root directory "/" to a given path given in the argument.
