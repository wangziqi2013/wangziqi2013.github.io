---
layout: paper-summary
title:  "Touche: Towards Ideal and Efficient Cache Compression By Mitigating Tag Area Overhead"
date:   2020-06-06 18:25:00 -0500
categories: paper
paper_title: "Touche: Towards Ideal and Efficient Cache Compression By Mitigating Tag Area Overhead"
paper_link: https://dl.acm.org/doi/10.1145/3352460.3358281
paper_keyword: Touche; Cache Compression; Cache Tag
paper_year: MICRO 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes Touche, a cache compression tagging scheme for reducing tag storage overhead on compression cache slots.
Conventional cache compression schemes often require adding more tags for the same number of data slots, and loosen the 
static mapping relation between tag and data slots. This way, more logical lines can be stored in the compressed form within
a single data slot, while more than one tags are used to address them. A set lookup should read all the tags out and 
compare them with the requested address to determine if the requests hits or not.

The paper assumes a compressed Last-Level Cache (LLC) design, with arbitrary compression algorithms as long as the algorithm
has a way to identify compressed block size using a few bits inddicating compression type.
The paper observes that a tradde-off has to be made between cache area overhead and effective cache size benefit by
applying compression. Overprovisioning of tags per slot of course increases the chance that more compressed blocks
can be stored in the same data slot. This, however, requires more parallel tag read and comparison for every LLC access,
which increases both area and power consumption. On the other hand, some prior designs propose using superblocks to reduce
the number of tags per data slot. Superblocks are consecutive compressed blocks whose address tags can be encoded by a 
base address tag plus implicit offset in the data slot similar to sectors in a sector cache. In such a design, the cache 
set loses most of the associativity provided by overprovisioned tags, since only adjacent blocks can be stored in a way, 
resulting in reduced effective cache size.

The touche design solves this trade-off using hashed address tags. Hashing allows us to reduce the size of the tag given
that the chances of collision are low. The hashed tag, called a signature, can be stored in the tag array design for 
full-sized address tags with other signatures of compressed blocks in the same data slot. Signatures enable the 
cache lookup protocol to rule out cache misses in the early stages of the process, since they can be immediately
detected after a signature comparison. Cache hits, however, cannot solely depend on signatures, since signature collisions,
however low it is, must be adddressed. The paper then proposes storing the full address tags at the end of the data slot,
which are read out and compared against the requested address only if one or more signatures hit. Given the low 
probablities of collision, the data slot read cost is very likely going to be paid anyway, if a signature hit occurs, 
therefore rendering this scheme costless in terms of storage and latency in most cases. At the end of the paper, a similar
but more space effective scheme is also proposed for storing superblocks consisting of four adjacent compressed blocks.
The superblock is encoded in a way that is distinguashable from regular Touche blocks, which also has zero extra 
tag storage overhead. We next discuss each of these designs in details.

Signatures are generated when a request with an address is received. The set lookup protocol does not change. The higher
27 bits right after the index bits are used to generate the signature as follows. First, the 27 bits are divided into three 
9 bit segments. Then the three segments are XOR'ed together to form a 9 bit string. The 9 bit string is then divided into
4 bit and 5 bit parts. Both parts index into a table consisting of 16 and 32 randomly generated entries, the sizes of which
are 4 and 5 bits, respectively. After table lookup, the two entries from the tables are concatenated to form the final
9 bit signature. At system startup time, the cache controller populates these two tables with randomly generated strings,
which will be used for signature generation thruogout the rest of the power cycle.
