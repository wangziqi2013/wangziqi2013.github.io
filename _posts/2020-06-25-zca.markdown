---
layout: paper-summary
title:  "Zero-Content Augmented Caches"
date:   2020-06-25 10:47:00 -0500
categories: paper
paper_title: "Zero-Content Augmented Caches"
paper_link: https://dl.acm.org/doi/10.1145/1542275.1542288
paper_keyword: Cache; ZCA; Zero Compression
paper_year: ICS 2009
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

**Highlight:**

1. Using a data-less sector cache organization to store zero blocks. This avoids one of the biggest problem of sector
   cache: low space utilization if spatial locality is low.

**Lowlight:**

1. Writing to zero blocks may incur unnecessary coherence messages for requesting exclusive permission. This is 
   because the sector cache has not way of distinguishing a S state block from an E state block.

This paper proposes zero-content augmented caches (ZCA cache), a simple cache compression scheme that only compresses
zero-filled 64 byte blocks. The paper begins by identifying three important properties of zero-filled blocks in 
common workloads. First, a non-trivial number of cache blocks are filled with zero for reasons such as zero initialization
or using zeros to represent a common state (e.g. NULL pointers, default values). Such regularities in application's data
value pattern enable the cache controller to perform zero compression by eliminating the need to store these easily
compressable blocks. In addition, some applications even demonstrate high percentage of zero blocks throughout the entire
execution, indicating the effectiveness of zero compression on these workloads.
Second, zero blocks themselves exhibit spacial locality. If one cache block is filled with zeros, the adjacent blocks are
also likely to be filled with zero, suggesting a design using larger block size per tag to handle zero blocks. 
The last observation is that writes to zero blocks also tend to be zeros sometimes, which further proves the effectiveness
of zero compression. The compression should also be performed on a per-write basis to detect zero writes for maximim
chances of compression.

The ZCA design can be deployed on any of the levels in the hierarchy. It is expected to retain the original lookup latency
of the cache, and therefore will not affect cache lookup performance.
ZCA extends the existing cache object with a small data-less sector cache. Each tag in the the sector cache represents the 
zero status of a large range of memory. Since zero blocks do not need any physical storage, the sector cache does not 
need a data array. Instead, a vector of valid bits suffices for describing zero status of all standard sized blocks in 
the sector. The paper also notes that although there is no hard limit of how large a sector could be, it is not recommended
to have sectors larger than a physical page, since locality on virtual addresses is only meaningful within a page. Addresses
that are close to each other on different virtual pages may be mapped to different physical pages by the underlying OS,
which undermines the effectiveness of sectors.

To minimize design complexity, the paper also suggests that only clean zero blocks be stored in the sector cache. This
design has three benefits. First, no data path is needed to evict a dirty block from the sector cache, as all blocks in
all sectors are clean. Second, there is no need to add a dirty bit vector to indicate whether a block has more recent
content than its lower level counterparts. Third, in the case of external coherence events, these zero lines are always 
assumed to be in a clean and potentially shared state. Similarly, when the cache controller intends to write a 
zero block in the sector cache, exclusive permission must always be obtained from all peer caches.

On a cache read request, both the normal cache and the sector cache are probed in parallel. At most one of these two
can signal a hit, since they maintain mutually exclusive data. If the hit is on the sector cache, then no actual
data is returned, and the cache controller simply sets the MSHR for the request to all-zero. 
If the request misses both caches, the controller forwards the request to the lower level as usual. When the refill 
response comes back, the controller checks whether the block is a zero block by OR'ing all bits in the block together.
In the case of a zero block, the block is inserted into the sector cache by setting the corresponding valid bit, if the 
sector tag exists, or, if the sector tag does not exist, an existing entry is evicted silently and the new entry is 
inserted.
