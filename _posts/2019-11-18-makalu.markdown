---
layout: paper-summary
title:  "Makalu: Fast Recoverable Allocation of Non-Volatile Memory"
date:   2019-11-18 14:12:00 -0500
categories: paper
paper_title: "Makalu: Fast Recoverable Allocation of Non-Volatile Memory"
paper_link: https://dl.acm.org/citation.cfm?doid=2983990.2984019
paper_keyword: NVM; malloc; Makalu; Memory management
paper_year: OOPSLA 2016
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Makalu, a memory allocator for byte-addressable non-volatile memory. This paper identifies three challenges
of implementing memory allocator for NVM due to its non-volatility. The first challenge is to maintain the consistency of 
allocator metadata, since memory allocator itself also maintains a set of data structures, both non-volatile core and 
volatile auxiliary data structure, to facilitate efficient allocation and deallocation. To reduce persistency overhead
of changing non-volatile states atomically with regard to failures, prior researches usually only maintain the consistency 
of core data structure, while relying on a post-crash recovery routine to rebild auxiliary data structures. This way, 
most allocation requests can be satisfied using DRAM-only auxiliary data structure, while the costly NVM allocation can 
be amortized. The second challenge is to ensure that each block is allocated at most once even after crash. If core
metadata is not maintained properly, already allocated block may appear as free after recovery, causing double allocation
and data corruption. This challenge is usually solved by persisting the fact that a block has already been allocated to
the NVM before returning the address of the allocated block to the application. If the system crashes before the persist
completes, the memory block will not be used by the application, and it will be free after recovery. If, on the 
other hand, the crash happens after the persist completes, the block will not be reused by the allocator after recovery,
since the NVM image indicates that the block is already allocated. The third challenge, which is also the most important
one, is to avoid memory leak after crash recovery. Memory leaks on NVM are more severe than in volatile memory system,
since leaks are permanent, and cannot be reset by restarting the system. Memory leaks occur if the system crashes
after a block is marked as allocated, retuened by the allocator, but before it is linked into the application. In fact,
in the most common programming paradigm using malloc(), 