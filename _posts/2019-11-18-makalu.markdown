---
layout: paper-summary
title:  "Makalu: Fast Recoverable Allocation of Non-Volatile Memory"
date:   2019-11-18 14:12:00 -0500
categories: paper
paper_title: "Makalu: Fast Recoverable Allocation of Non-Volatile Memory"
paper_link: https://dl.acm.org/citation.cfm?doid=2983990.2984019
paper_keyword: NVM; malloc; Makalu; Memory management
paper_year: OOPSLA 2016
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Makalu, a memory allocator for byte-addressable non-volatile memory. This paper identifies three challenges
of implementing memory allocator for NVM due to its non-volatility. The first challenge is to maintain the consistency of 
allocator metadata, since memory allocator itself also maintains a set of data structures, both non-volatile core and 
volatile auxiliary data structure, to facilitate efficient allocation and deallocation. To reduce persistency overhead
of changing non-volatile states atomically with regard to failures, prior researches usually only maintain the consistency 
of core data structure, while relying on a post-crash recovery routine to rebild auxiliary data structures. This way, 
most allocation requests can be satisfied using DRAM-only auxiliary data structure, while the costly NVM allocation can 
be amortized. The second challenge is to ensure that each block is allocated at most once even after crash. If core
metadata is not maintained properly, already allocated block may appear as free after recovery, causing double allocation
and data corruption. This challenge is usually solved by persisting the fact that a block has already been allocated to
the NVM before returning the address of the allocated block to the application. If the system crashes before the persist
completes, the memory block will not be used by the application, and it will be free after recovery. If, on the 
other hand, the crash happens after the persist completes, the block will not be reused by the allocator after recovery,
since the NVM image indicates that the block is already allocated. The third challenge, which is also the most important
one, is to avoid memory leak after crash recovery. Memory leaks on NVM are more severe than in volatile memory system,
since leaks are permanent, and cannot be reset by restarting the system. Memory leaks occur if the system crashes
after a block is marked as allocated, retuened by the allocator, but before it is linked into the application. In fact,
in the most common programming paradigm using malloc(), the pointer returned is first stored in a volatile local variable
(or register, which is also volatile), whose content is initialized, and then transferred to a field in the persistent 
data structure. In this paradigm, there is a short time window in which the allocated block belongs to neither the allocator
nor the data structure. If crash occurs in this time window, the block will be permanently lost, since no reference 
to the block exists after crash recovery. To solve this problem, prior researches propose using a new allocation paradigm, 
which consists of three steps. In the first reservation step, the address of the memory block is returned to the caller,
but the allocation is still held pending. If a crash happens, the allocator owns the block, since only volatile state
is modified to reflect the fact that the block has been allocated. In the second initialize step,
the application initializes the content of the block. In the last activation step, the address of the target word in
persistent data structure, as well as the pointer to the block, is passed to an activation function. The activation
function atomically transfers the ownership of the block from the allocator to the application, by directly writing the 
address of the block to the target word and removing the block from the allocator's metadata the NVM. This process can
be implemented with redo write-ahead logging, which commits the activation by the last atomic persistence of the 
log commit mark. If crash happens after the commit point, the recovery routine will locate and replay the log, which
makes it appear that the crash actually happened after the application has linked the block into the data structure.

Makalu solves the first two challenges exactly as we have described in the previous paragraph. To solve metadata consistency
problem, Makalu makes a clear distinction between core and auxiliary metadata. Core metadata consists of chunk headers, block
headers, and the metadata for the persistent file (assuming DAX file access protocol using mmap()). Core metadata is always 
persistent by using undo logging, and is maintained on the NVM. Auxiliary data structures, such as block and object free 
lists, are maintained only in DRAM, which will be lost after a crash or normal shutdown. Other auxiliary data structures, 
such as block header maps, and bitmaps within object block headers, have one persistent copy in NVM and one volatile copy
in DRAM. Only the volatile copy is used and updated during regular operation. On a normal shutdown, these metadata are 
written back to the corresponding NVM area to avoid a time consuming rebuild on every restart after normal shutdown.