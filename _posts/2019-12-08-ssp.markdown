---
layout: paper-summary
title:  "SSP: Eliminating Redundant Wrints in Failure-Atomic NVRAMs via Shadow Sub-Paging"
date:   2019-12-08 22:01:00 -0500
categories: paper
paper_title: "Optimizing Systems for Byte-Addressable NVM by Reducing Bit Flipping"
paper_link: https://dl.acm.org/citation.cfm?id=3358326
paper_keyword: NVM; SSP; Shadow Mapping; Double Buffering
paper_year: MICRO 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes SSP, a hardware framework for achieving persistent transactions on byte-addressable non-volatile 
memory system. The paper points out that existing software schemes, such as logging, shadow mapping, and log-structured
update, are all inefficient in terms of both latency and throughput. For example, in the most two common logging schemes,
redo logging and undo logging, old or new data must be written and flushed back to the NVM before the corrsponding location 
can be updated in-place to avoid dirty data cache line being evicted back to the NVM before the log entries are persisted. 
This introduces two problems. The first problem is write amplification, since data is written twice (if we consider 
metadata writes and log truncation overhead, the overhead is even larger). The second problem is that the write ordering
between log entries and in-place updated data is critical for correctness. Programmers must issue a software write barrier
which stalls the processor until previous stores are accepted by the memory controller every time write ordering is desired. 
For shadow mapping, one of the biggest concerns is write amplification, which can be significant when the amount of dirty
data per tracking unit (e.g. 4KB pages) is small. Even if only a few cache lines are updated per page, the original
page must be duplicated before update is conducted. In addition, shadow paging requires that every load and store to 
NVM area be translated by a translation layer, which identifies the current active version to be updated, and re-writes
the target address for the memory operation. On commit, all dirty contents are written back to the in-memory shadow page, 
and the stable version is switched from the old page to the new page atomically. This can be achieved by software 
instrumentation provided by the compiler, or by a hardware mapping structure. Both will add the overhead of address translation
and metadata maintenance to the critical path. Log-structured updated leverages the fact that NVM performs the best for 
sequential writes, and that atomic multi-word update can be achieved in an append-only manner by first appending data
to the end of the log, and then switching the pointer to the log tail with an atomic 8-byte write. Updated are not committed
until the atomic write is flushed back to the NVM. To facilitate runtime address computation, log-structured systems maintain
a virtualized linear address space, in which addresses are mapped to offsets into the log by a volatile mapping table.
The mapping table is updated every time an address is updated and appended to the end of the log. On a recovery, we rebuild 
the mapping table by scanning the entire log without having to recover the potentially inconsistent image from the NVM
(the table is in volatile DRAM for lower access latency). The major concern of log-structured system is the overhead of 
garbage collection, resulting in unnecessary data movement and data fragmentation.

