---
layout: paper-summary
title:  "SuperMem: Enabling Application-transparent Secure Persistent Memory with Low Overheads"
date:   2019-12-12 17:12:00 -0500
categories: paper
paper_title: "SuperMem: Enabling Application-transparent Secure Persistent Memory with Low Overheads"
paper_link: https://dl.acm.org/citation.cfm?id=3358290
paper_keyword: NVM; SuperMem; Counter Mode Encryption
paper_year: MICRO 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes SuperMem, a hardware design optimized for counter mode encryption. This paper identifies a few problems
of existing counter mode encryption schemes. First, current hardware platform does not guarantee tha atomicity of persistence
for more than one cache line sized block, which introduces the problem of inconsistent data block and counter value. To solve
this issue, prior researches have proposed large battery-backed buffer on the memory controller to allow both the counter
and the block to be buffered, upgrading the basic unit of atomicity from one cache line to two cache lines. Such a design,
however, may significantly change the underlying hardware, or become difficult to implement on commercial systems. 
The second problem is that prior proposals do not take advantage of the potential locality in the access pattern of most
applications. Counter mode encryption essentially doubles the number of cache lines written into the NVM device by updating
the counter array whenever a cache line is evicted or flushed from the LLC. If care is not taken, this can easily become
a performance bottleneck since the effective bandwidth of the NVM is halved. The last problem is that certain proposals 
change NVM programming interface by adding additional directives to the library for optimizing counter accesses. For example,
in Selective Counter-Atomicity (SCA), it is observed that atomicity of updates are not required for data when undo/redo logging
is used. This observation is based on the fact that when the transaction is interrupted by the crash before commit, the 
data updated by the transaction is inconsistent anyway, which will then be discarded by the recovery process using undo 
log entries or restored using redo log entries. The atomicity requirement for counter updates on these data can therefore 
be relaxed to avoid stalling the processor waiting for the write back to complete. In order to achieve selective atomicity
of memory updates, SCA adds a special programming construct which issues counter cache write back instruction when executed,
which acts like a barrier after which all pending counter and data updates are completed. The paper points out that although
moderate speedup is achieved by combining SCA with logging, the change in software interface makes it difficult to use, 
since most logging implementations reside in the library, which is out of the control of application programmers. 

The paper assumes the following baseline hardware. First, counter mode encryption is employed to provide access to the NVM, 
the content of which can only be accessed with a secure key. The baseline counter mode encryption works by dedicating 1/8
storage on the NVM device to store 8 byte counters for each cache line sized block on the NVM. When a cache line is evicted 
out of the LLC, the corresponding counter used to encrypt this line is also sent to the memory controller for persistence.
The baseline design does not assume any synchronization between these two requests, and is hence susceptible to inconsistencies
caused by power loss. We address this problem in SuperMem by adding an extra register to ensure that both data and counter
are persisted atomically. In order to better overlap counter access and data access, a counter cache is added at the LLC
level to remove NVM reads for frequently accessed counters. When a memory requests misses the LLC, the cache controller 
initiates two requests in parallel, one for accessing the NVM device, and the other for accessing the counter cache. Since
the counter cache has lower latency than NVM, the counter value will be returned before the read completes. The cache controller
then generates the OTP (One-Time Padding) using the counter, the access address, and the secret key. When the read completes,
the read value is XOR'ed with the OTP, and the decoded result is sent to the cache hierarchy. This scheme avoids adding
a significant number of cycles for decoding the cache line, since bitwise XOR is a fast operation. 

SuperMem differs from previous propals in three aspects. First, SuperMem does not assume any extra state backed by battery
(ADR) on the memory controller, and only adds one extra register for stashing counter values when the cache line is not
yet available. Second, SuperMem expolits spacial locality of access by encoding counters for cache lines within a page
in a way such that they can be stored in a 64 byte cache line. 