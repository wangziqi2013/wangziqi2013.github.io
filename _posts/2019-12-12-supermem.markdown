---
layout: paper-summary
title:  "SuperMem: Enabling Application-transparent Secure Persistent Memory with Low Overheads"
date:   2019-12-12 17:12:00 -0500
categories: paper
paper_title: "SuperMem: Enabling Application-transparent Secure Persistent Memory with Low Overheads"
paper_link: https://dl.acm.org/citation.cfm?id=3358290
paper_keyword: NVM; SuperMem; Counter Mode Encryption
paper_year: MICRO 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes SuperMem, a hardware design optimized for counter mode encryption. This paper identifies a few problems
of existing counter mode encryption schemes. First, current hardware platform does not guarantee tha atomicity of persistence
for more than one cache line sized block, which introduces the problem of inconsistent data block and counter value. To solve
this issue, prior researches have proposed large battery-backed buffer on the memory controller to allow both the counter
and the block to be buffered, upgrading the basic unit of atomicity from one cache line to two cache lines. Such a design,
however, may significantly change the underlying hardware, or become difficult to implement on commercial systems. 
The second problem is that prior proposals do not take advantage of the potential locality in the access pattern of most
applications. Counter mode encryption essentially doubles the number of cache lines written into the NVM device by updating
the counter array whenever a cache line is evicted or flushed from the LLC. If care is not taken, this can easily become
a performance bottleneck since the effective bandwidth of the NVM is halved. The last problem is that certain proposals 
change NVM programming interface by adding additional directives to the library for optimizing counter accesses. For example,
in Selective Counter-Atomicity (SCA), it is observed that atomicity of updates are not required for data when undo/redo logging
is used. This observation is based on the fact that when the transaction is interrupted by the crash before commit, the 
data updated by the transaction is inconsistent anyway, which will then be discarded by the recovery process using undo 
log entries or restored using redo log entries. The atomicity requirement for counter updates on these data can therefore 
be relaxed to avoid stalling the processor waiting for the write back to complete. In order to achieve selective atomicity
of memory updates, SCA adds a special programming construct which issues counter cache write back instruction when executed,
which acts like a barrier after which all pending counter and data updates are completed. The paper points out that although
moderate speedup is achieved by combining SCA with logging, the change in software interface makes it difficult to use, 
since most logging implementations reside in the library, which is out of the control of application programmers. 