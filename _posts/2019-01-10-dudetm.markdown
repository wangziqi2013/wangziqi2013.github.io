---
layout: paper-summary
title:  "DudeTM: Building Durable Transactions with Decoupling for Persistent Memory"
date:   2019-01-10 16:16:00 -0500
categories: paper
paper_title: "DudeTM: Building Durable Transactions with Decoupling for Persistent Memory"
paper_link: https://dl.acm.org/citation.cfm?id=3037714
paper_keyword: NVM; HTM; Transaction
paper_year: ASPLOS 2017
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes DudeTM, a persistent transactional memory design which guarantees not only atomicity, consistency, 
isolation, but also durability. DudeTM is built upon Non-Volatile Memory (NVM), where read latency is close or equal
to that of DRAM, and write operations are orders of magnitudes slower than reads. Another prominent feature of NVM
is that unlike hard disks where data can only be accessed by block I/O, NVM supports byte addressable, DRAM style 
accessing interface, making it an ideal replacement for DRAM modules when persistency is desired. Transactions on NVM
are said to be persistent, if the atomicity property of transactions can still be guaranteed in case of failure: Either
all operations or no operation in the transaction is executed. In practice, it is often interpreted as the ability for 
the transaction processing system to guarantee that transactions committed before the crash can be recovered, while 
uncommitted transactions must be rolled back.

Two classical ways of realizing persistent transactions are undo and redo logging. In undo logging, transactions update 
data items on the persistent storage in-place, after they save the original value of the item somewhere else on the 
persistent storage. This is to ensure that even if the system crashes halfway during the execution when only part of the 
transaction's output is written, it is still possible for the recovery handler to find out the fact that the transaction
has not completed before the crash, and hence restore the original values from the undo log. The cost of undo logging
is that the processor must issue a memory fence between the store instruction that saves the old value and the store 
instruction that updates the item in-place. This is to ensure that the log will reach persistent storage first, and then
the new value. Otherwise, the recovery handler may not be able to restore the old value if the system crashes before 
the log entry reaches persistent storage and after the new value has been written. With redo logging, transactions do not 
write dirty items in-place. Instead, dirty items are kept in a transactional-local buffer as a redo log. On every 
transactional read operation, the buffer must be checked to make sure that the value generated by the transaction can be 
seen by the transaction itself. This requires a mapping structure, and the structure will be queryed for every read
operation within the transaction. On transaction commit, the redo log is flushed to the NVM first for persistency, and 
then data items are updated in-place such that following reads can access the updated value. On recovery, the handler
reads the redo log from the persistent storage. If the redo log indicates that the transaction has committed, then 
values in the redo log will be replayed in the order consistent with the serial order for each transaction. 

Neither undo logging nor redo logging is ideal for a persistent transaction processing system. The former penalizes write
operations while the latter penalizes reads. In contrast, DudeTM achieves both cheap reads and writes using shadow pages. 
Every virtual page in DudeTM is backed by two physical frames: One from the persistent NVM, another from the volatile DRAM.
The overall architecture is quite similar to