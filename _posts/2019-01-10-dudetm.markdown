---
layout: paper-summary
title:  "DudeTM: Building Durable Transactions with Decoupling for Persistent Memory"
date:   2019-01-10 16:16:00 -0500
categories: paper
paper_title: "DudeTM: Building Durable Transactions with Decoupling for Persistent Memory"
paper_link: https://dl.acm.org/citation.cfm?id=3037714
paper_keyword: NVM; HTM; Transaction
paper_year: ASPLOS 2017
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes DudeTM, a persistent transactional memory design which guarantees not only atomicity, consistency, 
isolation, but also durability. DudeTM is built upon Non-Volatile Memory (NVM), where read latency is close or equal
to that of DRAM, and write operations are orders of magnitudes slower than reads. Another prominent feature of NVM
is that unlike hard disks where data can only be accessed by block I/O, NVM supports byte addressable, DRAM style 
accessing interface, making it an ideal replacement for DRAM modules when persistency is desired. Transactions on NVM
are said to be persistent, if the atomicity property of transactions can still be guaranteed in case of failure: Either
all operations or no operation in the transaction is executed. In practice, it is often interpreted as the ability for 
the transaction processing system to guarantee that transactions committed before the crash can be recovered, while 
uncommitted transactions must be rolled back.

Two classical ways of realizing persistent transactions are undo and redo logging. In undo logging, transactions update 
data items on the persistent storage in-place, after they save the original value of the item somewhere else on the 
persistent storage. This is to ensure that even if the system crashes halfway during the execution when only part of the 
transaction's output is written, it is still possible for the recovery handler to find out the fact that the transaction
has not completed before the crash, and hence restore the original values from the undo log. The cost of undo logging
is that the processor must issue a memory fence between the store instruction that saves the old value and the store 
instruction that updates the item in-place. This is to ensure that the log will reach persistent storage first, and then
the new value. Otherwise, the recovery handler may not be able to restore the old value if the system crashes before 
the log entry reaches persistent storage and after the new value has been written.

