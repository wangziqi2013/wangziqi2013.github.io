---
layout: paper-summary
title:  "PMEM-Spec: Persistent Memory Speculation"
date:   2021-05-16 06:24:00 -0500
categories: paper
paper_title: "PMEM-Spec: Persistent Memory Speculation"
paper_link: https://dl.acm.org/doi/abs/10.1145/3445814.3446698
paper_keyword: NVM; PMEM-Spec; Speculation
paper_year: ASPLOS 2021
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes PMEM-Spec, a hardware mechanism for enforcing strict write ordering between the memory consistency
model and NVM device. 
The paper points out that write ordering is critical for NVM-related programming, since the order of memory operations
performed on the hierarchy often differs from the order that NVM device sees them. This is caused by the fact that the
cache hierarchy can arbitrarily evict blocks back to the NVM, while programmers have only very limited control over the
lifespan of blocks in the hierarchy.
Current x86 platform provides two primitives, namely clflush for flushing a dirty block back to the backing memory,
and sfence for ordering cache flushes. A software persist barrier is formed by using multiple clflush followed by 
an sfence in order to establish write orderings for write operations before and after the barrier.

Software barrier, however, is far from optimal, since it is implemented on software, and therefore, stalls the 
processor with fence instructions while previous stores are being persisted. 
This also restricts parallelism, since a thread can have at most one outstanding barriers, limiting hardware
level parallelism of the NVM device that can be taken advantage of.

Previous hardware proposals, on the other hand, solve this issue by allowing multiple "strands" of persist barriers
to be active for a single thread at the same time, or decouples memory consistency (i.e., visibility of a modification
from the perspective of other threads) from NVM consistency (i.e., when the NVM device sees a dirty block) such that 
persistency is moved to the background without stalling the core pipeline.
These proposals optimize towards efficiency, but the paper points out that they often bring excessively complicated
hardware, and are intrusive to the existing hierarchy such that the coherence protocol is modified.
Besides, the paper also points out that more complicated persistence models need programmers to annotate the
source code, which requires programmers to learn these models first as well as to understand the subtlety of 
different models.

PMEM-Spec adopts a different approach by not proactively enforcing memory consistency and NVM consistency, but 
optimistically assuming that these two will be equivalent in the majority of cases. In other words, it speculates
under the assumption that these two orderings are always identical. In the rare case where they are not, the hardware
detects a violation, and interrupts the offending process of the ordering issue. The process then rolls back 
the current transaction or FASE, and restarts. 
