---
layout: post
title:  "Understanding Ariel Core Simulation in SST"
date:   2021-11-08 02:04:00 -0500
categories: article
ontop: false
---

# Ariel Core

## Ariel Tunnel

`class ArielTunnel` implements the shared memory layout and parent-child synchronization between processes.
`class ArielTunnel` inherits from `class TunnelDef`, with `struct ArielSharedData` as the shared metadata between
processes, and `struct ArielCommand` as the message type.
`struct ArielCommand` is the unit of message exchange between the instruction source and the Ariel core simulator.
It is a multi-purpose class consisting of several `union`s. The class can either encode instructions that are 
being executed in the simulated binary, or special memory operations, such as `malloc()/free()` or DMA transfer, 
as high-level memory layout information.


## Ariel Frontend

The ariel frontend defined in `class ArielFrontend` is a generic interface for the Ariel core to obtain a tunnel object
as instruction source. The class itself is abstract and does not implement any concrete function.
Any instruction source can be implemented as a derived class of `class ArielFrontend`, and be incorporated seamlessly
into Ariel core.

Specifically, the SST package provides an implementation, `class Pin3Frontend`, that works with Pin3, which is a binary 
instrumentation tool that dynamically rewrites application image in the main memory, such that the instruction trace 
can be obtained by invoking call backs after every instruction.
The instrumentation part (called a "pintool") is implemented as a separate module using the Pin library, and 
compiled into a dynamic library.
The program to be instrumented must be started as a separate process by invoking the pin binary with the pintool and 
program's binary. The pin binary will set up the execution environment for the pintool, load the application binary,
and then execute the binary with the instrumentations defined in the pintool.

`class Pin3Frontend` implements this process by calling `fork()` to create a child process, and then `execvp()`
to load the pin binary with command line arguments, including the path to the pintool, the path to the application 
binary, and arguments for running the application.
`class Pin3Frontend` also sets up the shared memory region, and pass the region name to the fork'ed child process
running Pin.
At the other side of the IPC channel, the pintool also contains a non-master mode Ariel tunnel object 
(`class ArielTunnel` in non-master mode) and a shared memory child object (`class MMAPChild_Pin3`).
Instructions intercepted by the instrumentation are sent over the tunnel object as message objects 
(`class ArielCommand`), which can be extracted on the simulator side and then fed into the Ariel core simulator.

`class Pin3Frontend`'s constructor takes the parameter object that stores various invocation parameters for the pin
binary, the number of cores, and the size of the queue objects in the tunnel.
Pintool path and application binary path are specified with `arieltool` and `executable`, respectively.
If the pintool path is not specified, it will, by default, be `fesimple.so`, which is compiled from `fesimple.cc`.
The path of the Pin binary is specified with `launcher`, which defaults to macro value `PINTOOL_EXECUTABLE`.
We do not cover the rest of the parameters here, and readers should be able to find the list of parameter options
and their definitions in file `pin3frontend.h`.
The constructor also creates the shared memory region and initializes the layout of the region by constructing a 
`class MMAPParent` object as data member `tunnelmgr`, and obtains the tunnel object (of type `class ArielTunnel`) as 
data member `tunnel`.
The key to map the shared region in another process is stored in local variable `shmem_region_name`, which will
be passed to the pintool in the command line.

When `init()` is called during the timed initialization stage, `forkPINChild()` will be called to bootstrap Pin.
This function first calls `fork()` to create a new child process, and then calls 
`execvp()/execve()` (depending on whether environmental variables are needed) to load the 
pin binary with the path to the pintool and the application binary. Other arguments, 
such as the shared region's name, are also passed via the second argument of `execvp()/execve()`.

The newly spawned process will then start, finish the initialization of the non-master tunnel object in the child
process, and registers itself on the shared memory region.
The SST process will wait for the child process to register by calling `waitForChild()` on the tunnel object,
and then the initialization concludes.

