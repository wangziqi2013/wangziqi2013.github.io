---
layout: post
title:  "Understanding Ariel Core Simulation in SST"
date:   2021-11-08 02:04:00 -0500
categories: article
ontop: false
---

# Ariel Core

## Ariel Tunnel

`class ArielTunnel` (in file `ariel_shmem.h`) implements the shared memory layout and parent-child synchronization 
between processes.
`class ArielTunnel` inherits from `class TunnelDef`, with `struct ArielSharedData` as the shared metadata between
processes, and `struct ArielCommand` as the message type.
`struct ArielCommand` is the unit of message exchange between the instruction source and the Ariel core simulator.
It is a multi-purpose class consisting of several `union`s. The class can either encode instructions that are 
being executed in the simulated binary, or special memory operations, such as `malloc()/free()` or DMA transfer, 
as high-level memory layout information.

`class ArielTunnel` behaves similarly to the base class, except that it defines a few more data member in 
`struct ArielSharedData`. Simulation time and cycle are tracked by `simTime` and `cycles`. 
`numCores` is simply the number of buffers in the shared region. `child_attached` tracks the number of child processes
(running non-master tunnel objects) that have registered themselves with the master tunnel object.

If the Ariel tunnel is being initialized on the child process, the process will register itself to the master
by incrementing the `child_attached` counter in `struct ArielSharedData`.
The current implementation does not use atomic instruction for the increment operation, which can potentially break
due to data contention, if multiple child processes increment it at the same time. It is, however, safe in practice,
since the Ariel core is only expecting one child process.

Function `waitForChild()` is called on the SST side after spawning child processes. This function contains a single 
loop that repeatedly checks the `child_attached` variable in the shared region. It exits the loop when this variable
is no longer zero, meaning that the (supposedly single) child has registered.

## Ariel Frontend

The ariel frontend defined in `class ArielFrontend` is a generic interface for the Ariel core to obtain a tunnel object
as instruction source. The class itself is abstract and does not implement any concrete function.
Any instruction source can be implemented as a derived class of `class ArielFrontend`, and be incorporated seamlessly
into Ariel core.

Specifically, the SST package provides an implementation, `class Pin3Frontend`, that works with Pin3, which is a binary 
instrumentation tool that dynamically rewrites application image in the main memory, such that the instruction trace 
can be obtained by invoking call backs after every instruction.
The instrumentation part (called a "pintool") is implemented as a separate module using the Pin library, and 
compiled into a dynamic library.
The program to be instrumented must be started as a separate process by invoking the pin binary with the pintool and 
program's binary. The pin binary will set up the execution environment for the pintool, load the application binary,
and then execute the binary with the instrumentations defined in the pintool.

`class Pin3Frontend` implements this process by calling `fork()` to create a child process, and then `execvp()`
to load the pin binary with command line arguments, including the path to the pintool, the path to the application 
binary, and arguments for running the application.
`class Pin3Frontend` also sets up the shared memory region, and pass the region name to the fork'ed child process
running Pin.
At the other side of the IPC channel, the pintool also contains a non-master mode Ariel tunnel object 
(`class ArielTunnel` in non-master mode) and a shared memory child object (`class MMAPChild_Pin3`).
Instructions intercepted by the instrumentation are sent over the tunnel object as message objects 
(`class ArielCommand`), which can be extracted on the simulator side and then fed into the Ariel core simulator.

`class Pin3Frontend`'s constructor takes the parameter object that stores various invocation parameters for the pin
binary, the number of cores, and the size of the queue objects in the tunnel.
Pintool path and application binary path are specified with `arieltool` and `executable`, respectively.
If the pintool path is not specified, it will, by default, be `fesimple.so`, which is compiled from `fesimple.cc`.
The path of the Pin binary is specified with `launcher`, which defaults to macro value `PINTOOL_EXECUTABLE`.
We do not cover the rest of the parameters here, and readers should be able to find the list of parameter options
and their definitions in file `pin3frontend.h`.
The constructor also creates the shared memory region and initializes the layout of the region by constructing a 
`class MMAPParent` object as data member `tunnelmgr`, and obtains the tunnel object (of type `class ArielTunnel`) as 
data member `tunnel`.
The key to map the shared region in another process is stored in local variable `shmem_region_name`, which will
be passed to the pintool in the command line.

When `init()` is called during the timed initialization stage, `forkPINChild()` will be called to bootstrap Pin.
This function first calls `fork()` to create a new child process, and then calls 
`execvp()/execve()` (depending on whether environmental variables are needed) to load the 
pin binary with the path to the pintool and the application binary. Other arguments, 
such as the shared region's name, are also passed via the second argument of `execvp()/execve()`.

The newly spawned process will then start, finish the initialization of the non-master tunnel object in the child
process, and registers itself on the shared memory region.
The SST process will wait for the child process to register by calling `waitForChild()` on the tunnel object,
and then the initialization concludes.

## Ariel Pintool

The pintool that works with Ariel core is implemented in file `fesimple.cc`, and will compile into a dynamic library,
`fesimple.so`. 
The pintool implements the instrumentations that are essential to obtain instruction traces within the potentially
multi-threaded application, as well as to capture certain operations, such as `malloc()/free()` and the stack trace.
The pintool runs a `class ArielTunnel` object in non-master mode, which is referred to by global variable `tunnel`, 
and a shared memory IPC endpoint of type `class MMAPChild_Pin3`, which is referred to by global variable `tunnelmgr`.
The name for the shared region is passed via command line argument from the SST process via `execvp()/execve()`,
and is received by Pin's `KNOB` object `SSTNamedPipe`. 
Other parameters to the pintool are also passed via command line, and received by `KNOB` objects, which we do not
cover here. Readers should be able to obtain a fairly detailed description of these parameters and their descriptions
in file `fesimple.cc`.

