---
layout: paper-summary
title:  "Stash: Have Your Scratchpad and Cache It Too"
date:   2021-08-27 21:29:00 -0500
categories: paper
paper_title: "Stash: Have Your Scratchpad and Cache It Too"
paper_link: https://dl.acm.org/doi/10.1145/2749469.2750374
paper_keyword: Scratchpad memory; Stash; GPGPU
paper_year: ISCA 2015
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes Stash, a globally addressable, cache coherent scratchpad memory architecture for GPGPU. 
The paper is motivated by the fact that existing commercial implementations of scratchpad memory has limited efficiency
and usability due to the private, non-cache coherent address space. Stash addresses these issues by allowing the
scratchpad memory to translate its private address to and from the global virtual address, such that the scratchpad
memory can be loaded like a traditional cache on-demand, while maintaining easy access by retaining the direct 
addressing and fine-grained access capabilities of existing scratchpad memory.

The paper recognizes that both cache and scratchpad memory have limitations. Cache memory, on one hand, requires 
expensive address translation and tag lookups for each operation, which implies extra energy consumption in addition to
data access. Furthermore, cache memory has a fixed size block interface, meaning that data must be transferred between
the cache and the main memory in the unit of blocks, which is sub-optimal in both storage and bandwidth if only
a small potion of the block is used. Such striding pattern is common in certain GPGPU applications, if, for example, a 
single field of an array of structs (AoS) is accessed in parallel.

Scratchpad memory, on the other hand, overcomes the above limitations by allowing direct and fine-grained addressing 
into its storage, entirely getting rid of the tag array and the block interface.
It, however, suffers another two types of inefficiencies.
First, current implementations of scratchpad memory has its own isolated address space, meaning that applications must
explicitly move data into the scratchpad memory by issuing memory instructions. These explicit memory instructions 
will pollute the cache with data that is unlikely to be reused, as most of the operations will take place on the
scratchpad memory.
Second, scratchpad memory is not cache coherent, which implies that software must issue extra load and write back
instructions to ensure the correctness of data. For example, data updates in the scratchpad memory needs to be reflected
back to the global memory by software issuing explicit data movement instructions. Similarly, if data
items is updated by the CPU, software should also check whether the version stored in the scratchpad memory is
still up-to-date. Both requirements incur extra software and runtime complexity.

Stash combines the advantage of both cache and scratchpad memory, while avoiding their shortcomings, by adding an extra
address translation layer between scratchpad memory address space and the global address space.
Stash optimizes over the case where a field of a struct, the size of which is one or a few words, in an AoS is accessed,
and the access takes place in a stride pattern within one rectangular block of a 2D tile.


