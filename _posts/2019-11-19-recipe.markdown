---
layout: paper-summary
title:  "Recipe: Converting Concurrent DRAM Indexes to Persistent-Memory Indexes"
date:   2019-11-19 23:10:00 -0500
categories: paper
paper_title: "Recipe: Converting Concurrent DRAM Indexes to Persistent-Memory Indexes"
paper_link: https://dl.acm.org/citation.cfm?id=3359635
paper_keyword: NVM; B+Tree
paper_year: SOSP 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper propes Recipe, a code transformation technique for implementing failure atomic persistent data structures
from their concurrent but non-persistent counterparts. The paper is motived by the fact that persistence and isolation
are, in fact, similar to each other since they both require that data structure be able to recognize partially updated
states, and fix them cooperatively during execution. In other words, most data structures require that operations
be atomic with regard to other concurrent operations. This can be achieved by making the changes publicly available
using one atomic step. In the meantime, if we need failure atomicity on data structure, they must commit all changes 
to the NVM and make them available to post-crash recovery routines in one atomic step, such that either all necessary
information is on the NVM for replay all the changes, or none of them is available after recovery.

The paper makes the following assumption. First, it is assumed that either a NVM-specific memory allocator is used
to replace the volatile allocator, or the language runtime is able to perform garbage collection in the background.
In either case, the garbage collector should ensure the consistency of its own metadata internally to avoid corrupting
internal metadata or allocating the same block more than once. If a memory block has been allocated (i.e. removed 
from allocator's free list) but not yet linked into the data structure, it will be lost after the crash since the ownership
transfer is non-atomic. The garbage collector should be able to find these leaked blocks