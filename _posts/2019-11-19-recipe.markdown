---
layout: paper-summary
title:  "Recipe: Converting Concurrent DRAM Indexes to Persistent-Memory Indexes"
date:   2019-11-19 23:10:00 -0500
categories: paper
paper_title: "Recipe: Converting Concurrent DRAM Indexes to Persistent-Memory Indexes"
paper_link: https://dl.acm.org/citation.cfm?id=3359635
paper_keyword: NVM; B+Tree
paper_year: SOSP 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper propes Recipe, a code transformation technique for implementing failure atomic persistent data structures
from their concurrent but non-persistent counterparts. The paper is motived by the fact that persistence and isolation
are, in fact, similar to each other since they both require that data structure be able to recognize partially updated
states, and fix them cooperatively during execution. In other words, most data structures require that operations
be atomic with regard to other concurrent operations. This can be achieved by making the changes publicly available
using one atomic step. In the meantime, if we need failure atomicity on data structure, they must commit all changes 
to the NVM and make them available to post-crash recovery routines in one atomic step, such that either all necessary
information is on the NVM for replay all the changes, or none of them is available after recovery.

The paper makes the following assumption. First, it is assumed that either a NVM-specific memory allocator is used
to replace the volatile allocator, or the language runtime is able to perform garbage collection. In either case, the 
garbage collector should ensure the consistency of its own metadata internally to avoid corrupting internal metadata or 
allocating the same block more than once. If a memory block has been allocated (i.e. removed from allocator's free list) 
but not yet linked into the data structure, it will be lost after the crash since the ownership transfer is non-atomic. 
The garbage collector should be able to find these leaked blocks either by an offline scan before the restart, or 
by performing online background GC. The second assumption is that read operations must be non-blocking, while write
can be blocking, but there should be a way of transforming writes to perform atomic updates between consistent states.
As we will see later, this assumption forms the basis of code transformation. The last assumption is that the data
structure's concurrency support must be correct. A buggy parallel implementation will result in a buggy persistent
implementation. 

On a high level, Recipe works by allowing intermediate states caused by modification operations on the data structure, 
including data updates and structural updates, to be exposed to concurrent threads. Without proper synchronization, such 
intermediate states will lead to errorneous behavior due to loss of information (e.g. maybe some information is temporarily
copied to the local execution stack of the thread carrying out the modification operation), or due to contradictory metadata
(e.g. metadata update is non-atomic), or read corrupt data (e.g. data update is non-atomic, and other threads read partially
written data). To ensure the correctness of updates, data structure must satisfy the following requirements when
performing updates. First, each step in a single update operation only atomically transform publicly available states from 
one consistent state to another. This can always be done by performing log-structured updates: A log pointer or "validity bitmap"
is maintained for each object that will be updated concurrently, which marks the end of the currently available log or 
indicates "active slots" in the object (if it consists of slots, such as a B+Tree node). In order to perform atomic updates, 
threads first allocate some space at the end of the log or acquire a free slot. Then threads updathe the object by
appending to the log or writing data into the unused slot just acquired. During this process, data appended to the 
log or written to the slot is unavailable to other readers. In the last step, the updates are committed by atomically
moving the log tail pointer or setting the bit in "validity bitmap" by using an atomic CAS. The second requirement is that
threads must be able to recognize such intermediate states, and help-along when they observe an incomplete update. To
achieve this, either all update operations on objects explicitly identify themselves, like in BwTree and BzTree (PMWCAS),
by posting a record indicating an incomplete operation, which contains the operation type and arguments for completing
the operation, or update operations are carefully designed such that they create unique intermediate states with
sufficient information to complete or roll back the operation. This property makes crash recovery trivial, since 
after the crash, threads simply fix the data structure in the intermediate states back to normal using the same logic as 
it does during normal execution.