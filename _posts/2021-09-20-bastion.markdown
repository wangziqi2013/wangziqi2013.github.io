---
layout: paper-summary
title:  "Scalable Architectural Support for Trusted Software"
date:   2021-09-20 18:04:00 -0500
categories: paper
paper_title: "Scalable Architectural Support for Trusted Software"
paper_link: https://ieeexplore.ieee.org/document/5416657
paper_keyword: Security; Enclave; Bastion
paper_year: HPCA 2010
rw_set:
htm_cd:
htm_cr:
version_mgmt:
--- 

This paper proposes Bastion, a secure computing architecture built into the CPU core that allows secure execution
of trusted hypervisors, software modules, and secure storage of data on external devices. 
The paper is motivated by the fact existing mechanisms for secure computing are neither comprehensive, nor efficient,
indicating that a single mechanism is not sufficient to protect all system components without incurring high
overhead. Bastion, on the other hand, provides a set of simple hardware interfaces for integrity verification, access 
control, and encryption/decryption, and relies on a trusted (and dynamically verified) hypervisor to protect 
both dynamic execution, data access, and external I/O of applications.

The paper begins with a discussion of the limitations of existing secure computing techniques. Virtual Machine Monitors
(VMMs) are a popular option, because it offers hardware-assisted isolation between kernels. This provides a great 
advantage over schemes that rely on the kernel to be not compromised, as the protected application can be 
executed on a separate VMM instance using its own trusted OS. VMMs, however, incurs great overhead as well, since 
switching to the protected application involves a world switch into another VMM instance.
The paper also lists limitations of other proposed designs. First, some of them lack scalability, since they 
need dedicated hardware resource per protected region, meaning that the number of protected regions is upper bounded
by the number of available hardware resources. 
Second, these proposals lack flexibility since they do not take software context into consideration (**I did not 
understand what does this mean in the paper**). 
Lastly, some proposals assume that the hardware will be physically intact, which are prone to hardware attacks,
such as using malicious bus agents to tap on the memory bus or actively corrupt data, or accessing the external
storage by physically mounting it on a non-secure host.

Bastion surpasses previous proposals by having a rather comprehensive threat model. Bastion assumes that all system
components, including the OS, the memory bus, the main memory modules, and the external devices, are all unreliable
in a way that they are prone to software and/or hardware attacks. The only two trusted components in Bastion are the 
hypervisor, which is from a trusted software distributor and is always integrity-verified before every boot, and 
the CPU chip containing the core pipeline, the caches, and the Bastion hardware.
The paper argues that despite the fact that the CPU chip can also be physically tapped or even altered, the technical
difficulty in doing so is astronomical as modern chips are manufactured into multiple layers of logical gates and 
wires, making it almost impossible to attach a CPU chip.
The paper also noted that Bastion does not intend to protect application from side-channel or covert channel attacks.

As mentioned above, Bastion relies on a trusted hypervisor to carry out all the security related actions, which itself
is verified at boot time. Protected applications can be co-hosted by the same hypervisor in the same untrusted OS.
The hypervisor may perform its address translation from guest virtual to host physical using either shadow page
tables, or nested page tables (the latter is adopted by later hardware virtualization features).
No matter which address translation scheme is used, the paper also assumes that the hypervisor has ultimate control
of the translation entries installed into the TLB. On an architecture that does not have a page walker and relies the
OS to install the entry, this can be done naturally as control is transferred to the hypervisor for installing the entry
on a TLB miss. On architectures with a page walker, the paper proposes that the MMU should raise an interrupt to the
hypervisor after the page table entry has been fetched from the memory, such that the hypervisor always has a 
chance to modify the entry to be inserted into the TLB (e.g., the entry to be installed is made available to the 
hypervisor).

The Bastion root of the trust starts with a boot-time validation of the hypervisor. The validation is performed by a 
short code sequence stored in an on-chip secure memory (which is assumed to be safe from attacks). The 
code sequence is triggered by an instruction, namely secure\_launch, which is invoked by the untrusted boot loader
after it has loaded the hypervisor module into the main memory.
The secure\_launch instruction calls into the validation procedure, which computes the hash of the current hypervisor
image, and stores it in a register "hypervisor_hash". This hash value is then compared with a non-volatile register,
storage\_owner\_hash, which is the hash value of the hypervisor that created the secure storage.
If both hashes match, then the other two non-volatile registers, namely secure\_storage\_key and secure\_storage\_hash,
are exposed to the hypervisor as the cryptographic key for decoding the contents in the secure storage and for 
validating the integrity of the secure storage, respectively.
The three volatile registers are initialized when a hypervisor is booted on the machine for the first time, and 
their values will persist across power cycles (it is not known how to implement them on real hardware, though).
Secure storage will be discussed later as one of the security features provided by Bastion.
If the hypervisor validation fails, either because the hypervisor is corrupted, resulting to a different hash, or
because a malicious boot loader circumvents the secure\_launch instruction, the secure storage will not be 
accessible, and the Bastion hardware will simply just destroy the secure storage by erasing the persistent registers.
