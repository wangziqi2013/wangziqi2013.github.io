---
layout: paper-summary
title:  "NVWAL: Exploiting NVRAM in Write-Ahead Logging"
date:   2019-10-28 13:40:00 -0500
categories: paper
paper_title: "NVWAL: Exploiting NVRAM in Write-Ahead Logging"
paper_link: https://dl.acm.org/citation.cfm?id=2872392
paper_keyword: NVM; WAL; SQLite; NVWAL; Database
paper_year: ASPLOS 2016
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes NVWAL, a technique for improving log performance on SQLite, a widely adopted DBMS on mobile platforms.
The current logging mechanism on SQLite stores block-level journals to the file systems. The journal is written first to 
persistent storage before data items are updated. The transaction is logically committed by appending a special commit record
to the journal after all log entries are persistent, and before any data item is updated. This way, the transaction can always
be replayed after a crash by reapplying all the log entries in the journal. The journal of a transaction can be truncated, 
if all dirty pages affected by the transaction has been written back to persistent storage, or overwritten by a later 
transaction (note that since logging is performed at page granularity, the detection of overwriting can also be done at
page level). 

This approach to logging offers a significant performance improvement over the older undo logging mechanism, which
requires writing back the undo log as soon as they are generated to prevent violation of write ordering. It is, however,
still not optimal, due to two reasons. First, the logging granularity is large compared with the usual granularity of
updates. The paper identifies that SQLite features frequent small updates, which are mainly made on the B+Tree structure.
Much of the I/O bandwidth for writing the log is wasted because only a small fraction of the logged page is actually useful.
The second reason for inefficiency is write amplification introduced by the file system. In order to maintain the consistencu
of metadata and data, the file system itself will also perform juornaling to the jounral data and affected metadata of the
journal file. The "journaling of the journal" problem introduces unnecessary overhead, since the journaling mechanism 
requires only very weak semantics guarantee. For example, POSIX mandates that file system should provide the abstraction 
of atomic writes, while the journal accepts the fact that any log flush can be interrupted by a failure as long as single
8-byte writes are atomic (i.e. the commit mark). The mismatch between the capability of the file system and the actual
requirement of the journaling mechanism amplifies writes, resulting in even more bandwidth waste. 

NVWAL solves the above two problems by moving the log object to NVM. Instead of creating a separate log file and relying
on the file system for maintaining metadata, NVWAL simply creates a persistent object using mmap() system call for 
requesting a chunk of persistent storage mapped to NVM addresses. The NVM address mapped to the process's address 
sapce is then divided into blocks, which is the basic unit of allocation and deallocation. To save the application
from a time consuming system call every time it needs a chunk of memory, NVWAL also maintains the allocator metadata 
itself, which permits both efficient storage management and correct recovery upon a failure. 

We describe the logging process as follows.