---
layout: paper-summary
title:  "BzTree: A High-Performance Latch-Free Range Index for Non-Volatile Memory"
date:   2019-11-10 16:00:00 -0500
categories: paper
paper_title: "BzTree: A High-Performance Latch-Free Range Index for Non-Volatile Memory"
paper_link: https://dl.acm.org/citation.cfm?id=3164147
paper_keyword: MWCAS; NVM; BzTree
paper_year: VLDB 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents BzTree, a lock-free and persistent B+Tree data structure designed for hybrid DRAM and NVM systems.
This paper identifies two atomicity requirements for in-memory B+Tree typically used as database indices. First, multi-step
updates should be atomic with regard to other threads. This avoids exposing some inconsistent intermedaite states to other
threads which may lead to data corruption or program failure. Second, multi-step updates should be atomic with
regard to the NVM. Either none of the operations or all of them should be reflected on the NVM image at any point during
execution. The problem, however, is that current hardware primitives are insufficient to guarantee any of these two, with 
reliable progress guarantee (HTM can satisfy the first requirement, but there is no progress guarantee unless a software 
fall back path is provided). 

This paper presents the implementation of BzTree, which achieves atomic tree update with regard to both other threads and 
the NVM. The atomicity guarantees of BzTree are delivered under a unified Multi-Word Compare-and-Swap (MWCAS) framework, 
in which multiple aligned machine words can be tested for expected values and then updated to new values if all tests are 
successful. In addition, the MWCAS primitive is extended with logging support which allows fast recovery upon a failure 
to reapply committed updates, while rolling back partial changes to recovery the data structure to a consistent state. 
These two combined together ensures that the structure of the tree is always consistent both in the DRAM and in the NVM 
at any moment during execution.

The MWCAS operation proceeds in two stages. The MWCAS implementation used by BzTree assumes that the target words are
either virtual address pointers, or small integers (much smaller than 2^64), or bit fields. In all three cases, we 
can dedicate three control bits from the target word for defining the type of the word, which we discuss as follows. 
The first bit is a "dirty" bit, which indicates that the current DRAM image may differ from the NVM image, and the value
may not be persisted when a crash happens. The MWCAS protocol dictates that a dirty value must be persised to the NVM
before they can be used. This is to prevent a thread accessing dirty data from making its own updates, which must
be rolled back if later on crash happens and the dirty data is lost and cannot be recovered. (NOTE: I personally do not
think this will happen). After persisting the word, the dirty flag can be cleared in the DRAM using a single word CAS.
Note that CAS is necessary in this case, since there can be concurrent modifications on the same word by other threads.

The remaining two bits are used to indicate whether the value stored in the target word is a regular value, a descriptor
of MWCAS, or a descriptor of RDCSS. RDCSS descriptors are used to implement Restricted Double Compare and Single Swap.
We use RDCSS in the first stage of MWCAS to avoid certain subtle race conditions that may break the atomicity of MWCAS.
After reading a value, threads should always check these two bits to see whether the value is temporarily locked by another 
thread by replacing the regular value with a descriptor. If it is the case, the thread should "help-along" and finish the 
incomplete RDCSS or MWCAS using information recorded in the descriptor. This "help-along" protocol makes BzTree unblocking,
since threads can always make progress by helping other threads finish their operations, even if when the initiating thread
of the operation is switched out by the OS. 
