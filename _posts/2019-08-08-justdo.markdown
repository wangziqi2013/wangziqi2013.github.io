---
layout: paper-summary
title:  "Failure-Atomic Persistent Memory Updates via JUSTDO Logging"
date:   2019-08-08 23:44:00 -0500
categories: paper
paper_title: "Failure-Atomic Persistent Memory Updates via JUSTDO Logging"
paper_link: https://dl.acm.org/citation.cfm?id=2872410
paper_keyword: Logging; JUSTDO; NVM
paper_year: ASPLOS 2016
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes JUSTDO logging, a novel logging and recovery method for non-volatile memory. In ordinary logging schemes,
such as undo logging, redo logging, and shadow logging, the amount of data (i.e. log records and metadata) is proportional
to the number of store operations. One log entry is generated for each store operation, which contains the address, data,
and other control information in order to roll back or redo the affected region. These schemes generally have three problems. 
First, they enforce write ordering at the guanularity of every store or every transaction commit. In the former case,
a log entry is generated before the store is performed, and the entry must be fllu flushed to the NVM device before the 
store could proceed to guarantee recoverability. Although with new hardware primitives and probably new architectures, the 
overhead of persisting can be overlapped by smart scheduling (e.g. hardware level write ordering enforcement), it still poses
a major overhead of logging schemes that require per-store logging, e.g. undo logging. In the latter case, the log records are 
flushed to the NVM at transaction commit point, which incurs a burst of traffic to the network and NVM. Even worse, the 
chance of overlapping this burst of memory write backs with other useful work is slim, because transaction commit always 
happens as the last action a transaction will take, which puts the persistence of log records on the critical path. This 
happens with redo logging. The second problem is that extra metadata, either on-chip or off-chip (e.g. on memory controller)
might be used to track the state of stores. These metadata themselves also require persistence for correct crash recovery, 
which introduces extra traffic, storage and complexity. 