---
layout: paper-summary
title:  "Romulus: Efficient Algorithms for Persistent Transactional Memory"
date:   2020-01-15 16:57:00 -0500
categories: paper
paper_title: "Romulus: Efficient Algorithms for Persistent Transactional Memory"
paper_link: https://dl.acm.org/doi/10.1145/3210377.3210392
paper_keyword: NVM; Transaction; Romulus
paper_year: SPAA 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Romulus, an NVM library that implements persistent critical regions and transactions. Traditional 
logging methods, such as undo or redo logging, either use too many persistent barriers to ensure writr ordering,
or requires read instrumentation to redirect read instructions to the redo log. Romulus solves both problems using shadow
paging in which each data item has two copies, one in the master copy (called main copy), the other in the backup copy
(called back copy). Romulus maintains the invariant that at any given moment in time, either the main copy is being 
mutated by an ongoing transaction and the back copy represents the last consistent state, or the main copy represents
the most up-to-date consistent state, and the back copy is being updated to match the new copy. This way, when the system
crashes, we always have a consistent copy of data to start the application with.

Romulus assumes that the persistent storage is exposed to the user address space via direct access (DAX) files. Physical
addresses are assumed to be mapped to the same virtual address on each restart, such that no extra pointer operation
is required to maintain the same pointer semantics. The DAX file is divided into three parts. The first part is the 
area header, which stores metadata on the DAX mapped file. This part is common in many NVM based designs, which stores
the name of the mapping, the metadata, and statistics information. 

Memory allocation