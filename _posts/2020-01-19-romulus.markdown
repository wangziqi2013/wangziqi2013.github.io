---
layout: paper-summary
title:  "Romulus: Efficient Algorithms for Persistent Transactional Memory"
date:   2020-01-15 16:57:00 -0500
categories: paper
paper_title: "Romulus: Efficient Algorithms for Persistent Transactional Memory"
paper_link: https://dl.acm.org/doi/10.1145/3210377.3210392
paper_keyword: NVM; Transaction; Romulus
paper_year: SPAA 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Romulus, an NVM library that implements persistent critical regions and transactions. Traditional 
logging methods, such as undo or redo logging, either use too many persistent barriers to ensure writr ordering,
or requires read instrumentation to redirect read instructions to the redo log. Romulus solves both problems using shadow
paging in which each data item has two copies, one in the master copy (called main copy), the other in the backup copy
(called back copy). Romulus maintains the invariant that at any given moment in time, either the main copy is being 
mutated by an ongoing transaction and the back copy represents the last consistent state, or the main copy represents
the most up-to-date consistent state, and the back copy is being updated to match the new copy. This way, when the system
crashes, we always have a consistent copy of data to start the application with.

Romulus assumes that the persistent storage is exposed to the user address space via direct access (DAX) files. Physical
addresses are assumed to be mapped to the same virtual address on each restart, such that no extra pointer operation
is required to maintain the same pointer semantics. The DAX file is divided into three parts. The first part is the 
area header, which stores metadata on the DAX mapped file. This part is common in many NVM based designs, which stores
the name of the mapping, the metadata, and statistics information. The most important thing in this part is a status 
variable describing the current progress of transactions and the after-commit copy process. The state variable can take
three values: IDLE, meaning no transaction is running on the file, and the main copy and the back copy are both consistent;
MUT, meaning a transaction is modifying the content of the file, and that the main copy can be in an inconsistent state;
COPY, meaning that the transaction has finished execution, but we are still copying the main copy to the back copy.
The transaction is considered as already committed in COPY state, because on a crash recovery, we just need to redo
this copy process, and then change the state variable to IDLE. The second and third part of the DAX mapped file are 
two copies of working data. As discussed above, at any point during execution, at least one of these two copies are 
consistent with the state of most recently committed transaction. Modifications are always made to the main copy by
user applications. The back copy is only written by library routines for synchronization after a transaction commit. 
Reading applications may or may not read into the back copy depending on the Romulus algorithm, as we will see below.

Memory allocation is also implemented within the persistent region. Allocator metadata and object list are both stored
at the beginning of the last two areas, such that the consistency of the allocator also depends on the consistency of
the two areas. Note that allocators must use relative offsets, because otherwise when the main image is copied to the 
backup, these pointers will still point to objects in the main copy, rather than the corresponding object in the backup. 
By implementing the allocator as part of the duplicated 