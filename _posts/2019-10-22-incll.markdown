---
layout: paper-summary
title:  "Fine-Grain Checkpointing With In-Cache-Line Logging"
date:   2019-10-22 11:47:00 -0500
categories: paper
paper_title: "Fine-Grain Checkpointing With In-Cache-Line Logging"
paper_link: https://dl.acm.org/citation.cfm?doid=3297858.3304046
paper_keyword: NVM, Undo Logging; Masstree
paper_year: ASPLOS 2019
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

**Highlights:**

1. Taking advantage of the fact that a pointer in x86-64 only has 48 effective bits. 

**Lowlights::**

1. wbinvd is a previleged instruction. On epoch boundaries a system call must be performed to flush the entire cache.

This paper presents In-Cache Line Logging (InCLL), a novel technique for accelerating undo logging in certain non-volatile
data structures. InCLL is motivated by the fact that traditional undo-based logging has an important implication: the 
undo log entry must reach the persistent NVM before dirty data does, because otherwise, when the system crashes, all in-cache
data will be lost, and there would be no way to recover the system state to the before state using undo image. With today's
commercial hardware, the write ordering between the log entry and dirty data (which can reside in different cache lines) 
must be enforced using cache flush and memory fence instructions, which can be inefficient if log flushes are frequent.

Instead of precise undo logging, InCLL adopts an epoch-based checkpointing model, in which the data structure is checkpointed
for every 50ms. The interval between two consecutive checkpoints is called an "epoch", during which the data stucture works
normally as the volatile version. On the epoch boundary, all worker threads are blocked until the checkpointing is completed, 
leaving the data structure in a consistent state (i.e. no operation is currently going on). A seperate checkpointing thread 
then flushes the system cache (using "wbinvd" instruction), after which all dirty cache lines are persistent in the NVM, 
making the NVM image also a consistent state. After a system crash, it is guaranteed that the state of the data structure 
can be restored to the consistent state in the previously completed checkpoint by applying the undo log entries to 
objects that are modified in the failed epoch. 

This paper uses Masstree as the platform to demonstrate how InCLL works with common data structures. Masstree is a combination
of B+Tree and Radix tree. Instead of having "flat" nodes as in a regular radix tree, a B+Tree is used to support extremely
large fanouts at each radix tree level. In masstree, each radix tree level has 2^64 fanouts, mapping a key of 64 bits to 
one of the next level B+Tree. The B+Tree, therefore, has fixed key length (8 byte binary data) and value length (8 byte 
pointers). To further reduce data movement when inserting or deleting elements, a permutation field is added into each node 
of the B+Tree, such that the elements need not be sorted. The permutation field is a 64 bit word mapping elements from their
sorted location to physical location within the node, which can be modified atomically with regular store instructions
if properly aligned. Each node of the Masstree consists 15 key-value pairs, plus the permutation field. 

InCLL extends the non-volatile Masstree to support efficient crash consistency based on the following observations. First, 
if the undo log and the dirty data resides in the same cache, no write ordering needs to be enforced, since existing
hardware all guaratee that a cache line is persisted atomically, i.e. either the entire cache line is persisted, or
none of it is persisted. Placing the undo log entry in the same cache line as dirty data therefore can reduce the 
cache flush and memory fence overhead, since either the dirty data is written back to the NVM during exeution, and so does
the undo log entry, or both of them are wiped out by the crash, doing no harm at all to the NVM image. The second observation
is that only the permutation field needs to be logged when inserting or deleting of elements from a node, since a physical
slot can be invalidated simplying by writing a special value into the permutation field. Initially, all fields in the 
permutation field indicates invalid mapping. When a new element is added, the key and value is appended to the physical
array, and the permutation field is modified to map the key's logical slot to its physical location in the node. In order
to undo this insert, simply restoring the permutation field to its before state is sufficient, as the newly inserted key
and value will be demapped once the original permutation is restored. The same reasoning also applies to deletion of keys.
The last observation is that, for 