---
layout: paper-summary
title:  "Endurance Transient Inconsistency in Byte-Addressable Persistent B+Tree"
date:   2019-11-22 13:57:00 -0500
categories: paper
paper_title: "Endurance Transient Inconsistency in Byte-Addressable Persistent B+Tree"
paper_link: https://www.usenix.org/conference/fast18/presentation/hwang
paper_keyword: NVM; B+Tree; FAST; FAIR
paper_year: FAST 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents FAST and FAIR, a B+Tree implementation designed for byte-addressable NVM. The paper identified two
major challenges of designing persistent B+Tree. The first challenge is to handle inserts and deletes efficiently without
exposing intermediate states, especially when keys are longer than 8 bytes, which is the largest unit of atomic update
on NVM mapped memory with regard to failures. Classical B+Tree maintains a sorted array of keys for both inner nodes
and leaf nodes, in order to perform binary search. Inserting elements into the sorted array, as a consequence, involves
right shifting some elements to higher addresses to make a new slot in the middle of the array. Without proper design, such
element shifting may introduce temporary inconsistent states such as lost keys or accessing wrong child nodes. If the 
system crashes at this point, such intermediate state may not be able to be resolved. The second challenge is structural
modification operations (SMO) initiated by threads attempting to split or merge a node. B+Tree SMOs consists of several
steps, each of which will bring the affected nodes into inconsistent intermediate states. 



FAST & FAIR 