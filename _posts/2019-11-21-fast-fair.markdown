---
layout: paper-summary
title:  "Endurance Transient Inconsistency in Byte-Addressable Persistent B+Tree"
date:   2019-11-22 13:57:00 -0500
categories: paper
paper_title: "Endurance Transient Inconsistency in Byte-Addressable Persistent B+Tree"
paper_link: https://www.usenix.org/conference/fast18/presentation/hwang
paper_keyword: NVM; B+Tree; FAST; FAIR
paper_year: FAST 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents FAST and FAIR, a B+Tree implementation designed for byte-addressable NVM. The paper identified two
major challenges of designing persistent B+Tree. The first challenge is to handle inserts and deletes efficiently without
exposing intermediate states, especially when keys are longer than 8 bytes, which is the largest unit of atomic update
on NVM mapped memory with regard to failures. Classical B+Tree maintains a sorted array of keys for both inner nodes
and leaf nodes, in order to perform binary search. Inserting elements into the sorted array, as a consequence, involves
right shifting some elements to higher addresses to make a new slot in the middle of the array. Without proper design, such
element shifting may introduce temporary inconsistent states such as lost keys or accessing wrong child nodes. If the 
system crashes at this point, such intermediate state may not be able to be resolved. The second challenge is structural
modification operations (SMO) initiated by threads attempting to split or merge a node. B+Tree SMOs consists of several
steps, each of which will bring the affected nodes into inconsistent intermediate states. 

Prior researches have proposed adapting logging concepts used in database systems into B+Tree implementations. For example,
in order to update a single node atomically, an extra level of indirection is added to each node, which maps logical locations
of elements into physical locations in the node. The node is updated by first appending new elements into the end of the 
storage area, and then updating the mapping atomically using either 8 byte atomic update, or advanced techniques such as
Hardware Transactional Memory (HTM). Since elements are not logically committed until the last atomic update step, even
if the system crashes at some point during the update, intermediate results cannot be seen. This approach achieves easy
node update, at the cost of limiting the node layout and node size, since the mapping field length cannot exceed a cache 
line, which is the maximum unit of atomic persistence on the NVM side. 

FAST & FAIR 