---
layout: paper-summary
title:  "IMP: Indirect Memory Prefetcher"
date:   2019-01-07 00:52:00 -0500
categories: paper
paper_title: "IMP: Indirect Memory Prefetcher"
paper_link: https://dl.acm.org/citation.cfm?id=2830807
paper_keyword: Cache; Prefetching
paper_year: MICRO 2015
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes Indirect Memory Prefetcher (IMP) to address the common problem of slow indirect memory operations. 
Indirect memory operations are of the form A\[B\[i\]\], where B\[i\] is an array of indices that are read and used 
with a regular pattern, and A\[i\] stores data which are often accessed without a pattern. This scenario is common in 
compressed representation of sparse data structures. In practice, both arrays are pre-computed at the beginning of
an iteration, and remain unchanged during the iteration, because the compact form is difficult to modify. Access patterns 
like this suffer low spatial locality especially when the size of A is large, because it is unclear whether two adjacent 
elements in A will be physically stored close to each other. In addition, a classical stream prefetcher which detects 
regular access patterns as access streams also cannot help in this case, because the contents of B\[i\] usually do not result 
in a regular pattern of accessing A even if B itself is accessed regularly (e.g. using linear scans), making it harder for 
hardware prefetcher to work. 

In order to also efficiently prefetch array A, IMP takes advantage of the following observation: The address of 
A\[B\[i\]\] to prefetch is computed using a simple formula: &A\[B\[i\]\] == sizeof(A\[0\]) * B\[i\] + &A\[0\]. 
Given that the size of elements in array A is a compile time constant, and the base address of A is fixed at the beginning
of the iteration, this equation only contains one variable, B\[i\], and two unknown constants, sizeof(A\[0\] and &A\[0\]).
