---
layout: paper-summary
title:  "RowClone: Fast and Energy-Efficient In-DRAM Bulk Data Copy and Initialization"
date:   2021-05-13 05:05:00 -0500
categories: paper
paper_title: "RowClone: Fast and Energy-Efficient In-DRAM Bulk Data Copy and Initialization"
paper_link: https://dl.acm.org/doi/10.1145/2540708.2540725
paper_keyword: RowClone; DRAM
paper_year: MICRO 2013
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes RowClone, a fast data copy and initialization mechanism built into DRAM chips.
The paper points out that, on current memory architecture, data copy and initialization (specifically, zeroing out
a block) are two of the most commonly performed tasks, but yet very little optimizations exist.
On most platforms, these two tasks are performed by having the processor issuing instructions to fetch data into
the hierarchy, and then write it back to a different location. Some implementations optimize this using special
instructions provided by the ISA for this exact purposes. 
Two possible optimizations exist on today's x86. The first one is SIMD instructions, with which more than 64 bit
data can be read from the an address into an SIMD register, and written to another address. 
In addition, with non-temporal loads and stores, these instructions may bypass the cache hierarchy, and 
directly access DRAM to avoid cache pollution and the extra overhead of cache flushing. 
The second optimization is called Efficient MOVSB/STOSB (ERMSB), which takes advantage of existing 8086
string instructions and its prefixed form (REP prefix) as a hint to the microarchitecture that a string
operation is being performed, under which certain memory ordering constraints can be relaxed.

Despite the best efforts, current microarchitectural solutions are sub-optimal, since they all inevitably incur the
extra latency and bandwidth overhead of having to transfer data between the core pipeline and the main memory.
The paper observes that these overheads are unnecessary, since data copy and initialization can be performed within
the DRAM chip, with only minor modifications to the interval logic.

The paper assumes the following DRAM operation model. A DRAM device consists of banks and subarrays. Although
the actual physical device may have higher level abstractions such as channels and ranks, they are nothing more
than just a bunch of banks organized together for addressing and resource sharing purposes, and can be 
decomposed into a set of banks. 
Each bank consists of several subarrays, in which only one of them can be activated (this is an important factor
that restricts the design space, as we will see below). 
Subarrays are accessed in the unit of rows, the typical size of which are several KBs (8KB in this paper).
Each subarray has a row buffer, which stores the content of a row after activation. The row buffer is an important
component on RowClone's design as it serves as a temporary data buffer between two activations.

The access sequence of DRAM assumed by this paper is described as follows.
Before each access, the row index is generated using the physical address, and a word line is raised to select the 
row to be accessed. The bit lines of the row are opened by the word line signal enabling the access transistor 
connecting the capacitor and the signal output to the sense amplifier.
The sense amplifier then detects the charge at each capacitor, amplifies them to the normal logic level, and latch
them into the row buffer. Meanwhile, the values are also written back to the capacitors as they are latched by the
sense amplifiers. The latter is critical to the design of RowClone, as we will see later, this implies that 
if we activate another row in the same subarray, the content of the current row will be written back by the sense
amplifier as well, overwriting the existing content in the new row.
Data read and write are performed within the row buffer, and therefore, reads and writes have the same
sequence of commands.
After each activation, the sense amplifiers are pre-charged for the next access to a different row. This step,
however, is unrelated to RowClone's protocol, and we do not cover it in details.


