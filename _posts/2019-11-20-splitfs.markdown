---
layout: paper-summary
title:  "SplitFS: Reducing Software Overhead in File Systems for Persistent Memory"
date:   2019-11-20 23:07:00 -0500
categories: paper
paper_title: "SplitFS: Reducing Software Overhead in File Systems for Persistent Memory"
paper_link: https://dl.acm.org/citation.cfm?id=3359631
paper_keyword: NVM; File System; SplitFS
paper_year: SOSP 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

**Note: Despite promising results, I do not quite buy the paper's argument that Split file system can reduce
software overhead. I understand that using block swap instead of write-ahead logging can save you some I/O (writing
only once vs writing twice), but I cannot see how this reduce software overhead, or the paper uses the term "software
overhead" to refer to logging?

Another confusing argument in this paper is that while logical logging is used to enforce atomicity of multi-step operation
(which is an innovation), the paper did not mention that in order for this to work, we should issue fsync() to the 
underlying EXT4, and rely on atomicity guarantees of EXT4 and persistence guarantee of fsync() to logging abstract
operations of EXT4.**

This paper presents SplitFS, a user-space file system implementation aiming at reducing software overhead when running on
the NVM. Byte-addressable NVM is more sensitive to the overhead of software stack due to its lower latency and higher bandwidth
compared with conventional disks and SSD. The paper observes that most kernel file systems introduce non-negligible software
overhead by performing file system calls into the kernal on normal operations such as file open and read/write. For example,
the paper points out that on write operations, the file system has to perform block allocation, logging, metadata update, 
etc., which are all on the critical path. 

SplitFS features a hybrid architecture in which metadata operations are delegatd to existing kernel file systems such
as EXT4 DAX, while user data manipulation and semantics guarantees are delivered by a user space module. Building on top
of an existing file system has two obvious benefits. First, metadata operations are rarer compared with data operations,
while they often have subtle outcomes and implications, which on a software engineering point of view, is difficult to
get correct without many hours of testing. Rather than dedicating thousands of hours creating and debugging a brand new 
mechanism that will not be used as frequently as normal data operations, just relying on existing mechanisms will be 
a good balancing point reagrding both performance and ease of development. Second, EXT4 only delivers limited semantics
guarantees (i.e. POSIX), while in practice, a stricter or looser semantics may be desired. For example, the paper mentioned
that SQLite does not require data writes to be fully atomic with regard to failures, since data writes are protected by
logs, and log entry writes are ordered in a way that partially written log records can be identified. In such a use case,
if the file system provides atomic write guarantees, we will have a write amplification problem, because every data and 
log write will be first logged by the file system, which is unnecessary. On the other hand, if the file system provides
a strong support for atomicity and persistency of data, no logging is required even for transactional systems, as the 
logging can be done by the file system. SplitFS is able to provide different semantics guarantees by implementing flexible 
logging scheme in user space, which makes it more versatile. EXT4 DAX simply provides metadata atomicity guarantee, which
enables logical logging to be used. 

SplitFS provides three operating modes: POSIX, sync, and strict. Under POSIX mode, only metadata operations are guaranteed
to be atomic with regard to failures. They are not necessarily synchronized (i.e. metadata updates may not be persisted
and are prone to be lost even after the corresponding file system call returns). Data operations are neither atomic
nor syncrhronized. Under sync mode, metadata operations are atomic and synchronized, and data operations are only synchronized
but non-atomic. Note that atomicity does not imply synchronicity, since even if a write operation is atomic, the content
of the write can still be lost after a crash if it is not synchronous. Synchronicity also does not imply atomicity,
since synchronicity of write operations only dictate that the content of the write will not be lost after the operation
completes; Partial writes can still occur if the system crashed before the write can return. Under strict mode, all metadata
and data operations are atomic and synchronized, which means that their effect will be persistent right after the 
call returns, and if a crash happens before the operation completes, no harm will be done, and all partial updates
will be rolled back. In the following discussion, we focus on the strict mode to demonstrate how SplitFS levarages 
EXT4 DAX.

