---
layout: paper-summary
title:  "Wormhole: A Fast Ordered Index for In-memory Data Management"
date:   2023-02-02 19:29:00 -0500
categories: paper
paper_title: "Wormhole: A Fast Ordered Index for In-memory Data Management"
paper_link: https://dl.acm.org/doi/10.1145/3302424.3303955
paper_keyword: B+Tree; Trie; Hash Table; Wormhole
paper_year: EuroSys 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Wormhole, a hybrid trie-B+Tree index structure that enjoys the storage efficiency of B+Trees
with the lower lookup cost of a radix tree (i.e., a trie). The paper is motivated by the 
seemingly complementary space-time trade-offs of B+Tree and tries and proposes to combine the two to form a 
new data structure using path-compressed tries as the upper levels and B+Tree sorted-leaf nodes as the bottommost 
leaf level. The resulting tree structure combines the storage efficiency of compact key storage at the leaf level
and the time efficiency for lookups at the upper levels. Consequently, Wormhole outperforms the more conventional
index structures such as tries and even demonstrates close performance to constant-time hash tables with range query
support.

The paper begins by noticing the widening performance gap between ordered and unordered indexing structures.
Unordered indexing structures, such as hash tables, enable amortized constant-time lookup, hence suitable for
point queries but incapable of performing range queries. Ordered indexing structures, such as B+Trees and skip
lists, are constructed based on the partial ordering between keys. Lookup operations in these structures require one 
key comparison at each level, and the number of levels is proportional to the logarithm of the total number of
keys stored in the index, which degrades as the index becomes larger. Even worse, since most implementations of
ordered indexing structures use pointers to link "nodes" together in order to support mutation operations (i.e.,
insert, delete) efficiently, index traversal is essentially implemented as pointer-chasing, which is known for
its bad locality and low memory throughput.
