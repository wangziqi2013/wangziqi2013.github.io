---
layout: paper-summary
title:  "Wormhole: A Fast Ordered Index for In-memory Data Management"
date:   2023-02-02 19:29:00 -0500
categories: paper
paper_title: "Wormhole: A Fast Ordered Index for In-memory Data Management"
paper_link: https://dl.acm.org/doi/10.1145/3302424.3303955
paper_keyword: B+Tree; Trie; Hash Table; Wormhole
paper_year: EuroSys 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Wormhole, a hybrid trie-B+Tree index structure that enjoys the storage efficiency of B+Trees
with the lower lookup cost of a radix tree (i.e., a trie). The paper is motivated by the 
seemingly complementary space-time trade-offs of B+Tree and tries and proposes to combine the two to form a 
new data structure using path-compressed tries as the upper levels and B+Tree sorted-leaf nodes as the bottommost 
leaf level. The resulting tree structure combines the storage efficiency of compact key storage at the leaf level
and the time efficiency for lookups at the upper levels. Consequently, Wormhole outperforms the more conventional
index structures such as tries and even demonstrates close performance to constant-time hash tables with range query
support.

The paper begins by noticing the widening performance gap between ordered and unordered indexing structures.
Unordered indexing structures, such as hash tables, enable amortized constant-time lookup, hence suitable for
point queries but incapable of performing range queries. Ordered indexing structures, such as B+Trees and skip
lists, are constructed based on the partial ordering between keys. Lookup operations in these structures require one 
key comparison at each level, and the number of levels is proportional to the logarithm of the total number of
keys stored in the index, i.e., O(log(N)), which degrades as the index becomes larger. Even worse, since 
most implementations of ordered indexing structures use pointers to link "nodes" together in order to support 
mutation operations (i.e., insert, delete) efficiently, index traversal is essentially implemented as 
pointer-chasing, which is known for its bad locality and low memory throughput.

On the other hand, there also exists a type of indexing structure, called radix trees or tries, that gets rid of
key comparisons at each level. Instead, in radix trees, search keys are regarded as consisting of a string of 
"tokens". At each level during the traversal, the node of the next level is selected using the token as an index 
into the current node's pointer array. Radix trees also support range queries just like B+Trees and skip lists if 
the lexical order of keys is consistent with the partial ordering. In practice, this condition is already true 
for common key types, such as string keys. Integer keys, however, need to be transformed to big-endian format 
on small-endian machines (e.g., x86) before they can be used as order-preserving search keys in radix trees.
Compared with B+Trees and skip lists, radix trees enable O(L) lookup time where L is the number of tokens 
in the search keys. As the index grows, the time benefit of using radix trees gradually becomes obvious as 
O(log(N)), which is the time complexity of key lookups in B+Trees, will become bigger than O(L).
 
Wormhole combines a B+Tree and radix tree by borrowing the chained leaf structure from B+Tree and borrowing the 
trie structure for the upper levels. More specifically, in Wormhole, the bottommost level of the structure is 
identical to the leaf level of a B+Tree, i.e., a linked list of leaf nodes, in which key-value pairs are stored
in sorted order. Meanwhile, the upper level of the structure is a radix tree that maps lookup keys (called anchor keys) 
to the leaf nodes, and the number of keys in the upper-level radix tree equals the number of leaf nodes. 
During a traversal, the search key is first used to traverse through the radix tree until a leaf node is reached.
Then a regular B+Tree leaf search is performed on the leaf node to locate the key-value pair if the key exists.

One naive approach for generating the upper-level radix tree is to select the smallest key in each leaf node, and 
then construct a radix tree using these keys. However, this naive approach will likely generate a sub-optimal 
radix tree if the keys can be uniquely identified by only a prefix. To leverage key prefixes, instead of using the 
full keys to construct the upper-level radix tree, Wormhole proposes that we use the shortest prefix of the first
key in each leaf node as the anchor key for constructing the radix tree. In addition, the prefix should be chosen 
such that none of them is a prefix to the other. The paper describes the algorithm as follows. Given three 
consecutive nodes at the leaf level, i.e., A, B and C, if the anchor keys are already selected for A and C, then
the anchor key for B can be derived as the longest common prefix of the first key in node B and the last key in 
node A, plus the next token in the first key of node B. The derived anchor key is lexically larger than all keys 
in node A and is not a prefix of any keys in A. However, the anchor key generated this way can still be a prefix
of the anchor key for node C. In this case, the anchor key of B is further appended with an "end mark", which
is conveniently chosen as the smallest token that the paper assumes to be never used. For string keys, the 
smallest token can be any ASCII control character smaller than any of the printable characters.
After appending the end mark, the resulting anchor key for node B is smaller than the anchor key for node C,
while not being a prefix of the latter.
