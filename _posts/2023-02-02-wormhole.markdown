---
layout: paper-summary
title:  "Wormhole: A Fast Ordered Index for In-memory Data Management"
date:   2023-02-02 19:29:00 -0500
categories: paper
paper_title: "Wormhole: A Fast Ordered Index for In-memory Data Management"
paper_link: https://dl.acm.org/doi/10.1145/3302424.3303955
paper_keyword: B+Tree; Trie; Hash Table; Wormhole
paper_year: EuroSys 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Wormhole, a hybrid trie-B+Tree index structure that enjoys the storage efficiency of B+Trees
with the lower lookup cost of a radix tree (i.e., a trie). The paper is motivated by the 
seemingly complementary space-time trade-offs of B+Tree and tries and proposes to combine the two to form a 
new data structure using path-compressed tries as the upper levels and B+Tree sorted-leaf nodes as the bottommost 
leaf level. The resulting tree structure combines the storage efficiency of compact key storage at the leaf level
and the time efficiency for lookups at the upper levels. Consequently, Wormhole outperforms the more conventional
index structures such as tries and even demonstrates close performance to constant-time hash tables with range query
support.

The paper begins by noticing the widening performance gap between ordered and unordered indexing structures.
Unordered indexing structures, such as hash tables, enable amortized constant-time lookup, hence suitable for
point queries but incapable of performing range queries. Ordered indexing structures, such as B+Trees and skip
lists, are constructed based on the partial ordering between keys. Lookup operations in these structures require one 
key comparison at each level, and the number of levels is proportional to the logarithm of the total number of
keys stored in the index, i.e., O(log(N)), which degrades as the index becomes larger. Even worse, since 
most implementations of ordered indexing structures use pointers to link "nodes" together in order to support 
mutation operations (i.e., insert, delete) efficiently, index traversal is essentially implemented as 
pointer-chasing, which is known for its bad locality and low memory throughput.

On the other hand, there also exists a type of indexing structure, called radix trees or tries, that gets rid of
key comparisons at each level. Instead, in radix trees, search keys are regarded as consisting of a string of 
"tokens". At each level during the traversal, the node of the next level is selected using the token as an index 
into the current node's pointer array. Radix trees also support range queries just like B+Trees and skip lists if 
the lexical order of keys is consistent with the partial ordering. In practice, this condition is already true 
for common key types, such as string keys. Integer keys, however, need to be transformed to big-endian format 
on small-endian machines (e.g., x86) before they can be used as search keys in radix trees.
Compared with B+Trees and skip lists, radix trees enable O(L) lookup time where L is the number of tokens 
in the search keys. As the index grows, the time benefit of using radix trees gradually becomes obvious as 
O(log(N)) grows bigger than O(L).
