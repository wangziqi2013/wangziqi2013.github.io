---
layout: paper-summary
title:  "An Efficient Software Transactional Memory Using Commit-Time Invalidation"
date:   2019-11-03 15:58:00 -0500
categories: paper
paper_title: "An Efficient Software Transactional Memory Using Commit-Time Invalidation"
paper_link: https://dl.acm.org/citation.cfm?id=1772970
paper_keyword: STM; InvalSTM; FOCC
paper_year: CGO 2010
rw_set: Bloom Filter
htm_cd: FOCC
htm_cr: FOCC
version_mgmt: Lazy
---

This paper presents InvalSTM, an STM design based on forward optimistic co currency control (FOCC). The paper identifies
a few problems with commonly used concurrency scheme, BOCC, which is based on validation. First, BOCC only validates the 
committing transaction against committed transactions that can overlap its execution. If the write set of any of the 
overlapping transactions overlaps with the read set of the committing transaction, the latter has no choice but abort,
since otherwise we violate the commit order. One consequence of this process is that a writing transaction to address X
can abort all overlapping reading transactions on address X, making this scheme unfriendly for readers. Second, BOCC
buffers updates to memory in its private workspace, and delays the final validation step to the commit point. Such
lazy validation increases parallelism compared with eager conflict detection in which conflicts are detected as updates
are made. It is, however, possible for uncommitted transaction to access inconsistent data due to concurrent read
and commit. In other words, in BOCC, even if transactions are guranteed to be aborted if they reach the commit point,
there is even no guarantee that this commit point will be reached eventually due to undefined behavior such as infinite 
loops, corrupted control flow, etc.. To deal with inconsistent reads, BOCC based TM system must perform incremental validation
to ensure that all reads are consistent with regard to transaction begin time (i.e. all reads can be logically considered
to have happened at an atomic time when transaction begins). This incremental validation requires checking all reads in
the current read set, resulting in an O(n^2) extra cost where n is the number of reads in a single transaction (O(n) elements 
in the set and n checks performed, one for each read). The last problem is that for read-only transactions, BOCC still 
requires a validation step, which may result in the abort of the transaction. Being able to support read-only transactions
efficiently has been important to STM, since in fact many non-read-only transactions in its static form may turn out
as read-only.

This paper is based on invalidiation, which performs read-write set intersection in the "forward" direction (i.e. checking
with transactions that have not committed, looking forward into the future). In its simplest form, a FOCC scheme does 
not use any timestamp counter. Transactions are started by adding itself into a global list of active transactions.
Reads and writes are performed in the same way as in a BOCC transaction, that is, wrirtes are buffered in a local hash
table, while reads hitting the local write set will be forwarded from the write set, not read from shared memory. On
transaction validation, which happens once before commit, the validating transaction checks its write set against the 
read set of current active transactions. A conflict is detected if the read-write set intersection test results in non-empty
set. To resolve conflicts, either the currently validating transaction aborts, or the (potentially many) conflicting 
transactions abort, granting a degree of flexibility here. The contention manager can even let the validating transaction
wait for the conflict transaction to commit or abort before committing it (the paper does not explore this possibility,
though). After validation, the transaction commits by copying speculative writes into shared memory.