---
layout: paper-summary
title:  "Write-Behind Logging"
date:   2019-01-12 18:05:00 -0500
categories: paper
paper_title: "Write-Behind Logging"
paper_link: https://dl.acm.org/citation.cfm?id=3025116
paper_keyword: Logging; Durability; Transaction Processing; Database
paper_year: VLDB 2016
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes Write-Behind Logging (WBL), a novel technique that levarages Non-Volatile Memory (NVM) to solve 
the classical problem in databases: making transactions durable. In earlier works, people have proposed various schemes
to retain the consistency of database in cases of power failure (media failure and OS/DBMS failure are not considered,
because they usually corrupt data in an unpredicable manner that a recovery algorithm could not handle), where all 
in-memory works not flushed to durable storage are lost and there is no way to know which part of the database is consistent.
ARIES, as one example, uses both undo logging and redo logging to perform recovery. ARIES is intended for a disk-based 
database system with a managed buffer pool. To make it more realistic, two assumptions are made: First, dirty pages in 
the buffer pool may be written back to the disk at any time during transaction's execution. This assumption is made to
allow the buffer pool to swap in new pages when there is no free slot, as is the case with most buffer pool implementations.
As a consequence, before a transaction could commit, its dirty pages may overwrite valid data on the disk. On power failure,
the recovery algorithm must be able to recover the disk image to a state before the dirty pages were written out. The second
assumption is that dirty pages may not be flushed back to durable storage on transaction commit. This assumption improves 
transaction throughput, because for disk-based systems, writing dirty data back to the disk will most likely be random
writes, which can easily become the performance bottleneck. On recovery, the algorithm must be able to find back the 
committed values, even if they were not flushed to the disk before the crash. These two schemes, combined together,
is called "steal and no force". ARIES commit protocol is described as follows. During normal operations, the database monitors
write operations to the database. For each write, the physical before-image and after-image are both saved in the log. 
On transaction commit, the log record of the transaction must be flushed to the disk using fsync(). The transaction is 
considered as committed once fsync returns. Fuzzy checkpoints are also taken periodically to avoid log buffer overflow. The 
fuzzy checkpointing operation does not have to halt all transactions, and hence can complete faster than a synchronized 
checkpoint. Since uncommitted data may exist in fuzzy checkpoints, both redo and undo are needed to restore the 
database to a consistent state after a crash. 

There are three phases on ARIES recovery. In the first phase, the analysis phase, the recovery handler finds the most recent
checkpoint, and restores the status of transactions and dirty pages when the checkpoint was taken. It also restores the database
states using the checkpoint. Next, in redo phase, transactions that have already committed are replayed by the recovery 
handler. Only after-image of log records taken after and during the checkpoint are used for recovery. In the third phase, 
the undo phase, the recovery handler undoes modifications made to the database by uncommitted transactions. The set of 
uncommitted transactions are derived in the analysis phase. The before-image from log records are used to restore the 
database to the state before uncommitted transactions started. After the undo phase, the state of the database is consistent,
and new transactions can be processed.

With the performance advantage of NVM over disk I/O, WBL can achieve a better performance than WAL and ARIES, especially
on recovery time. Several design decisions are made to take advantage of fast and byte-addressable accesses to NVM. First,
WBL is designed to work with MVCC, where each data item is tagged with two timestamps: One begin timestamp, which is the 
timestamp of transaction that created this version (version update only creates new versions, and never delete existing version),
and one end timestamp, which is the begin timestamp of the next higher version in the version chain. Reading transactions 
traverse the version chain to find the version that is visible according to its timestamp (distributed using a centralized
counter similar to how OCC allocates timestamps). The version read rule states that a version with timestamps [ts1, ts2)
is visible to a transaction with begin timestamp ts if and only if (1) ts is within [ts1, ts2); and (2) the transaction
that writes the version has committed (note that ts2 can be &infin; as is the case for the most up-to-date version). 