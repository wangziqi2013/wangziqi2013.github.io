---
layout: paper-summary
title:  "FPTree: A Hybrid SCM-DRAM Persistent and Concurrent B-Tree for Storage Class Memory"
date:   2019-11-17 15:35:00 -0500
categories: paper
paper_title: "FPTree: A Hybrid SCM-DRAM Persistent and Concurrent B-Tree for Storage Class Memory"
paper_link: https://dl.acm.org/citation.cfm?id=2915251
paper_keyword: NVM; B+Tree
paper_year: SIGMOD 2016
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents FPTree, a B+Tree designed for byte-addressable non-volatile memory. This paper points out, at a high 
level, several challenges of implementing data structures for NVM. First, the data structure should be able to recover to
a consistent state after a crash. This is typically achieved by flushing certain data back to the NVM to enforce write
ordering between metadata (commit mark, log entry, etc.) and data using persistence barrier. Considering that NVM writes
are only atomic on 8 byte aligned words at the CPU side, and that data persistency is only atomic on cache line granularity
at the NVM side, partial writes might occur after a crash, if the crash happens during or after the write. There are three 
common patterns for ensuring consistency. The first pattern is writing data into invalid area (assumed to be initialized
to zero). This happens when inserting elements into a B+Tree node. In this case, we first acquire storage for the write, 
and then perform write. A valid mark is set only after the write completes and is flushed back to the NVM. The valid mark 
can be appended after the write as a log, or be set in a separate header structure. A second flush on the valid mark commits 
the write operation. Since the mark can be set with only 8 byte atomic writes, the commit operation is also atomic with 
regard to failures. The second pattern is writing data into invalid area, but allows data to be invalidated (deleted) before 
they can be written into again. This corresponds to insert and delete operation on a tree node. The first half (insertion)
is exactly the same as the previous pattern. The second half can be easily achieved by resetting the valid mark during 
the first half to a value indicating deleted entry, and then flushing the mark, which commits the delete operation. 
Garbage collection is required to reclaim deleted entries to avoid fragmentation. In the third pattern, an entry is first
inserted, which is handled as in the first pattern, and then updated without being deleted. If the update can be done with
8 byte atomic write, then we simply perform the update and then flush the value. Otherwise, we write a redo write-ahead 
log to describe the operation, flush the log, after which the actual content is updated in-place. The log can only be 
removed after we flush the in-place update back to the NVM. During recovery, the log entries are first processed by replaying
the operations recorded in the log.