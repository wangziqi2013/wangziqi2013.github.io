---
layout: paper-summary
title:  "STRAIGHT: Hazardless Processor Architecture Without Register Renaming"
date:   2019-08-15 19:32:00 -0500
categories: paper
paper_title: "STRAIGHT: Hazardless Processor Architecture Without Register Renaming"
paper_link: STRAIGHT: Hazardless Processor Architecture Without Register Renaming
paper_keyword: Register renaming; Straight; Microarchitecture
paper_year: MICRO 2018
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes Straight, a novel superscalar microarchitecture implementing out-of-order (OOO) execution without
register renaming. In ordinary architecture, in order to schedule instructions that have anti-dependencies out of the 
program order, registers must be renamed to avoid accidental overwriting of register contents. For example, if 
instruction I1 reads from register X, while a later instruction in the program order I2 writes register X, if I2 is 
scheduled before I1, then when I1 executes, it will read a value produced by I2, which violates the invariant that
single threaded execution must be equivalent to serial execution.

Regular register renaming schemes usually use a mapping table implemented as RAM or TCAM. There are two ways of designing
the mapping table. In the first scheme, the mapping table is a RAM, in which every entry corresponds to an architectural register,
and the content of the entry is the name of the physical register it maps to. Every time a new instruction passing the decode
stage overwrites an architectural register, a new physical register is allocated, and the entry is updated to the new
physical register. When an architectural register is used as source operands, the mapping table is accessed and the 
current name of the physical register is returned. To manage physical registers, an extra free list is also added to
allocate unused physical registers. Physical registers are only released when no future instruction could be reading it, using
either reference counting, or epoch-based mechanism (i.e. the register could be freed after the instruction that caused
its being overwritten in the mapping table commits). The second scheme of register renaming uses a TCAM whose size equals the 
number of physical registers. Each physical register corresponds to an entry in the TCAM. TCAM entries store the current 
architectural register that uses this physical register. No free list is maintained, because free physical registers 
can be obtained by acquiring a physical register not allocated to any architectural register. On instruction decoding,
the name of the architectural register is used to query the TCAM, which obtains the name of the physical register it is 
allocated with. On a register write instruction, a free entry is obtained from the TCAM, and then the name of the 
architectural register is stored into the free entry. Note that physical registers cannot be freed immediately after 
they are unmapped. The register recycling rule is identical to the rule of RAM-based design.

Both renaming schemes need to consider the case when a speculation path fails and have to be rolled back. In this case,
simply nullifying their instruction buffers in the pipeline is insufficient, because architectural state changes such
as allocations in the mapping table should also be rolled back. With the first RAM-based design, the paper suggests that 
a reorder buffer (ROB) walker should be invoked and undo all changes made by the speculation path (the ROB entry should 
record the before-image of the entry it affects for such undo operations). In the second TCAM-based design, since the 
entire TCAM can be snapshot in a single cycle quite efficiently, and that there is no extra data structure to maintain, 
the processor may take a snapshot on every point of speculation, and just restore the snapshot back to the mapping table.
In this scheme, it takes constant time to restore the snapshot, but as a trade-off, the storage required to store these
snapshots grows linearly with the maxmimum allowed depth of speculation.

Based on the above two possibilities of implementing register renaming, this paper identifies three potential problems
of the current scheme. First, in order to keep the OOO backend busy, it is expected that the frontend issue several
instructions into the instruction window every cycle. This, however, means that the mapping table needs to be accessed
and updated by multiple instructions in the same cycle, implying a multi-ported design whose complexity grows exponentially,
limiting the issue width of the pipeline. 
In addition, if these instructions have dependencies, the updates they made to the mapping table should be as if they were 
performed sequentially. This requires extra priority handling circult. For example, when if two instructions need renaming, 
they cannot be allocated the same physical register. The second problem is recovery cost. On a RAM-based design, recoverying
from a mis-speculation takes time proportional to the size of the mis-speculated path, because instructions are undone
one-by-one with a ROB walker. On a TCAM-based design, one snapshot is taken on each speculation, which requires significant
on-chip storage to buffer these snapshots, given that the number of physical registers are generally large on modern platform. 
The last problem is that the mapping table is accessed in every cycle where a register is accessed. This contributes not only to 
total power consumption, but also makes frequency scaling more difficult.