---
layout: paper-summary
title:  "STRAIGHT: Hazardless Processor Architecture Without Register Renaming"
date:   2019-08-15 19:32:00 -0500
categories: paper
paper_title: "STRAIGHT: Hazardless Processor Architecture Without Register Renaming"
paper_link: STRAIGHT: Hazardless Processor Architecture Without Register Renaming
paper_keyword: Register renaming; Straight; Microarchitecture
paper_year: MICRO 2018
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes Straight, a novel superscalar microarchitecture implementing out-of-order (OOO) execution without
register renaming. In ordinary architecture, in order to schedule instructions that have anti-dependencies out of the 
program order, registers must be renamed to avoid accidental overwriting of register contents. For example, if 
instruction I1 reads from register X, while a later instruction in the program order I2 writes register X, if I2 is 
scheduled before I1, then when I1 executes, it will read a value produced by I2, which violates the invariant that
single threaded execution must be equivalent to serial execution.

Regular register renaming schemes usually use a mapping table implemented as RAM or TCAM. There are two ways of designing
the mapping table. In the first scheme, the mapping table is a RAM, in which every entry corresponds to an architectural register,
and the content of the entry is the name of the physical register it maps to. Every time a new instruction passing the decode
stage overwrites an architectural register, a new physical register is allocated, and the entry is updated to the new
physical register. When an architectural register is used as source operands, the mapping table is accessed and the 
current name of the physical register is returned. To manage physical registers, an extra free list is also added to
allocate unused physical registers. Physical registers are only released when no future instruction could be reading it, using
either reference counting, or epoch-based mechanism (i.e. the register could be freed after the instruction that caused
its being overwritten in the mapping table commits). The second scheme of register renaming uses a TCAM whose size equals the 
number of physical registers. Each physical register corresponds to an entry in the TCAM. TCAM entries store the current 
architectural register that uses this physical register. No free list is maintained, because free physical registers 
can be obtained by acquiring a physical register not allocated to any architectural register. On instruction decoding,
the name of the architectural register is used to query the TCAM, which obtains the name of the physical register it is 
allocated with. On a register write instruction, a free entry is obtained from the TCAM, and then the name of the 
architectural register is stored into the free entry. Note that physical registers cannot be freed immediately after 
they are unmapped. The register recycling rule is identical to the rule of RAM-based design.

Both renaming schemes need to consider the case when a speculation path fails and have to be rolled back. In this case,
simply nullifying their instruction buffers in the pipeline is insufficient, because architectural state changes such
as allocations in the mapping table should also be rolled back. With the first RAM-based design, the paper suggests that 
a reorder buffer (ROB) walker should be invoked and undo all changes made by the speculation path (the ROB entry should 
record the before-image of the entry it affects for such undo operations). In the second TCAM-based design, since the 
entire TCAM can be snapshot in a single cycle quite efficiently, and that there is no extra data structure to maintain, 
the processor may take a snapshot on every point of speculation, and just restore the snapshot back to the mapping table.
In this scheme, it takes constant time to restore the snapshot, but as a trade-off, the storage required to store these
snapshots grows linearly with the maxmimum allowed depth of speculation.

Based on the above two possibilities of implementing register renaming, this paper identifies three potential problems
of the current scheme. First, in order to keep the OOO backend busy, it is expected that the frontend issue several
instructions into the instruction window every cycle. This, however, means that the mapping table needs to be accessed
and updated by multiple instructions in the same cycle, implying a multi-ported design whose complexity grows exponentially,
limiting the issue width of the pipeline. 
In addition, if these instructions have dependencies, the updates they made to the mapping table should be as if they were 
performed sequentially. This requires extra priority handling circult. For example, when if two instructions need renaming, 
they cannot be allocated the same physical register. The second problem is recovery cost. On a RAM-based design, recoverying
from a mis-speculation takes time proportional to the size of the mis-speculated path, because instructions are undone
one-by-one with a ROB walker. On a TCAM-based design, one snapshot is taken on each speculation, which requires significant
on-chip storage to buffer these snapshots, given that the number of physical registers are generally large on modern platform. 
The last problem is that the mapping table is accessed in every cycle where a register is accessed. This contributes not only to 
total power consumption, but also makes frequency scaling more difficult.

To solve the problem of register renaming, instead of using fixed name for registers (which are abstracted away by hardware 
anyway), Straight proposes that instructions explicitly specify source operands using an offset from the current instruction
back to the producer instruction the dynamic instruction flow. Two major changes are introduced into the ISA. First,
instructions no longer specify a destination register, because the "destination" of the instruction is encoded by the position
of the instruction in the ROB. Second, instructions refer to the result produced by other instructions using a relative offset
in the dynamic flow, which can only be determined at runtime. The second property complicates code generation, since in
some cases there can be producer instructions in different execution paths.

Straight assumes a RISC-like OOO superscalar pipeling model. Instructions are fetched and decoded in-order, which are then
pushed into the reorder buffer (ROB) in program order. Operands are only read from the physical register file at the cycle 
the instruction is issued, and results are written back into the register file at the last stage (retirement stage). In
particular, it seems that Straight does not assume a Tomasulo execution model in which completed instructions directly
forward its result to waiting instructions in the window (so an instruction can only have its operands ready when all dependent
instructions retire). Instructions can retire when they are at the head of the ROB.

Straight works as follows. At decoding stage, instructions are assigned physical registers beased on source operands.
The decoder maintains a register pointer (RP), which points to the next physical register to be allocated. Since 
most instructions will produce a value, every instruction is allocated a register by incrementing the RP when it is decoded.
The physical register ID is the value of the RP when the instruction is decoded (although the paper did not specify
what the physical register value is if the instruction does not produce a value, such as stores). This way, operand reading
is an easy task, because the physical register of previous instruction in the dynamic flow can be inferred from the offset.
To elaborate: If the current instruction's physical register ID is k, and the operand offset is x (which means that the 
operand is produced by the x-th instruction counting backwards from the current instruction in program order), then the 
source operand is from physical register (k - x), allowing wrap-around.