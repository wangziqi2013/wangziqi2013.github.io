---
layout: paper-summary
title:  "Rethinking the Memory Hierarchy for Modern Languages"
date:   2020-07-010 03:46:00 -0500
categories: paper
paper_title: "Rethinking the Memory Hierarchy for Modern Languages"
paper_link: Rethinking the Memory Hierarchy for Modern Languages
paper_keyword: Cache; Hotpads
paper_year: MICRO 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

**Highlight:**

1. Creating objects directly in the cache rather than alloc it first in VA space can help reducing compulsory cache misses.
   This is also leveraged in page overlays.

2. It is good thinking to treat caches as independent devices that have their own address spaces, rather than transparent
   faster storage for the PA space. This brings more interesting use cases and more algorithms that are originally designed
   for distributed systems.

**Lowlight:**

1. This design is really just a mixture of over-thinking and ad-hoc algorithms. I understand that the author
   may obtained the initial idea from software generational GC and felt motivated to port it to hardware. But really, GC
   and memory allocation is not a thing that you should perform purely on hardware. 
   Although the authors tried their best to make the design as flawless as possible, the inelegant ad-hoc and hardwired 
   logic and implicit assumptions make at least me uncomfortable when reading the paper.

This paper proposes Hotpads, an eccentric memory hierarchy architecture that optimizes for small object allocation, 
garbage collection in managed languages, memory safety, and reducing associative lookup costs in conventional cache
hierarchy. The paper is motived by three important observations on modern programming languages. First, modern languages
are mostly memory safe with object abstraction. The memory layout of objects are opaque to application code, which cannot
be directly addressed using pointer cast or pointer arithmetic, but only accessed with pre-defined methods. This reduces 
chances that unintended wild pointers, buffer overflows or malicious attacks from corrupting the state of objects.
The architecture, however, failed to provide such protection on ISA level, forcing language runtimes to implement their 
own memory protection mechanism.
Second, most modern languages rely on background automatic garbage collection to recycle dead objects, which takes a 
software thread to periodically scan objects in the background, which also potentially moves objects around for
compaction. The usage of GC algorithms is already a feature in these languages that is so common to justify a hardware 
implemented version be embedded in the cache system.
Lastly, the paper also points out that conventional cache systems require an associative lookup of the tag array for 
each cache access, which has large power overhead. The paper seeks to reduce such overhead by using pointers that directly
point to cache locations, rather than to the underlying physical address space. Cache accesses, in most cases, are 
just to follow the pointer to the data array and access its content without an associative address tag lookup.