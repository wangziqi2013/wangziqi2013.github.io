---
layout: paper-summary
title:  "Pisces: A Scalable and Efficient Persistent Transactional Memory"
date:   2020-02-02 23:02:00 -0500
categories: paper
paper_title: "Pisces: A Scalable and Efficient Persistent Transactional Memory"
paper_link: https://www.usenix.org/system/files/atc19-gu_0.pdf
paper_keyword: NVM; Transaction; Pisces
paper_year: USENIX ATC 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Pisces, a software transactional memory design for Non-Volatile DIMM. Pisces uses a limited form
of multiversion concurrency control (MVCC) protocol, dual version concurrency control (DVCC), to implement snapshot-isolation
(SI) transactional semantics. The paper points out that SI is feasible for NVM compared with serializability in terms of 
blocked readers. For serializable semantics, readers must wait for a dirty data item to be fully persisted and the transaction 
to be committed, before the read transaction does. On recovery, the logs of transactions must be replayed on the order 
consistent with data dependencies (also transaction's serialization order) to avoid incorrectly overwriting a value. 
For SI, however, only write-write conflicts are detected, and transactions are ordered by the order that they overwrite
data items. This prevents reading transactions from being blocked by a pending writing transaction it reads from, which
decreases transaction commit latency.

The paper assumes a baseline MVCC model as follows. Transactions maintain a private write set for storing uncommitted data.
Data items are maintained as a linked list of versions, each having a timestamp indicating the commit time of the transaction
that creates it. Only committed version is stored in the version chain. Uncommitted versions is buffered privately as described
above. A global timestamp counter maintains the current logical time. On transaction begin, the transaction reads the value 
of the global timestamp counter as the begin timestamp, bts. The bts is used when accessing data items for read and writes. 
On transactional reads, the version chain of the data item is traversed until the oldest version whose timestamp is smaller than
or equal to the bts is reached. This version is then accessed directly from the version chain to fulfill the read. For writes,
the version chain is traversed in the same manner as in reads. The version is duplicated in the private buffer of the writing
thread, before it can be updated by the write. If the data item is already in the buffer, then writes will be performed
on the data item without traversing the version chain. On commit, the transaction first locks all modified data items by
acquiring locks on the version chain. The lock blocks both concurrent commits and accesses, the reason of which will be 
explained below. After all data items are locked, the transaction validates itself by checking whether any other transaction
has committed on the locked items since it has started. This is done by comparing whether the latest commit timestamp
is larger than bts. If true, the transaction has detected a write-write conflict, which leads to an abort. If not, the 
transaction first acquires a commit timestamp, cts, by atomically incrementing the global counter, and uses the new value 
as cts. To ensure failure-atomicity of updates, the transaction then writes a redo log to the NVM for persistence. The 
redo log consists of dirty data items it has created in the write buffer. After the redo log is persisted, the transaction
updates version chain by copying updated versions with its cts as version timestamp. In the last step, the transaction
releases all locks in the write set, and completes. On recovery, redo logs are replayed in the order of the commit timestamp
to reflect the correct write ordering.

The paper identifies two issues with the above simple MVCC model. First, traversing version chains has a large overhead,
both because the reader thread must examine a large number of version timestamps, but also because the pointer chasing 
and the resulting cache misses. The second issue is that readers are still blocked while a transaction commits on the 
data item it intends to read. This is because the committing transaction acquires the commit timestamp before it persists
the write set. After the cts is acquired, all later transactions shuold be able to read committed data of the committing 
transaction. This, however, may not always be possible, since the operation of updating version chains for the entire 
write set is most likely not atomic. If reader threads are not blocked, then it is possible that the thread accesses
an incorrect version simply because the committing transaction has not updated the version chain to add its own version 
yet. In the above transaction model, the reader transaction must wait for the committing transaction to fully add its 
write set to the version chain before it can proceed to read.

Pisces solves the above two issues by adapting the following. First, only two versions are allowed, one current version,
another newer version. The current version is accessed in-place as the data item is normally stored. The newer version exists
in a transactional-local log, which is exposed to readers after the writing transaction commits. At most one pointer chasing
is required to find the correct version to read. To avoid having threads reading even older and non-existing versions,
when we update the current version in-place, we must wait for such threads to exit before the current version is updated.
