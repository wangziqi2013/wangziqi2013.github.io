---
layout: paper-summary
title:  "Pisces: A Scalable and Efficient Persistent Transactional Memory"
date:   2020-02-02 23:02:00 -0500
categories: paper
paper_title: "Pisces: A Scalable and Efficient Persistent Transactional Memory"
paper_link: https://www.usenix.org/system/files/atc19-gu_0.pdf
paper_keyword: NVM; Transaction; Pisces
paper_year: USENIX ATC 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Pisces, a software transactional memory design for Non-Volatile DIMM. Pisces uses a limited form
of multiversion concurrency control (MVCC) protocol, dual version concurrency control (DVCC), to implement snapshot-isolation
(SI) transactional semantics. The paper points out that SI is feasible for NVM compared with serializability in terms of 
blocked readers. For serializable semantics, readers must wait for a dirty data item to be fully persisted and the transaction 
to be committed, before the read transaction does. On recovery, the logs of transactions must be replayed on the order 
consistent with data dependencies (also transaction's serialization order) to avoid incorrectly overwriting a value. 
For SI, however, only write-write conflicts are detected, and transactions are ordered by the order that they overwrite
data items. This prevents reading transactions from being blocked by a pending writing transaction it reads from, which
decreases transaction commit latency.

The paper assumes a baseline MVCC model as follows. Transactions maintain a private write set for storing uncommitted data.
Data items are maintained as a linked list of versions, each having a timestamp indicating the commit time of the transaction
that creates it. Only committed version is stored in the version chain. Uncommitted versions is buffered privately as described
above. A global timestamp counter maintains the current logical time. On transaction begin, the transaction reads the value 
of the global timestamp counter as the begin timestamp, bts. The bts is used when accessing data items for read and writes. 
On transactional reads, the version chain of the data item is traversed until the oldest version whose timestamp is smaller than
or equal to the bts is reached. This version is then accessed directly from the version chain to fulfill the read. For writes,
the version chain is traversed in the same manner as in reads. The version is duplicated in the private buffer of the writing
thread, before it can be updated by the write. If the data item is already in the buffer, then writes will be performed
on the data item without traversing the version chain. On commit, the transaction first locks all modified data items by
acquiring locks on the version chain. The lock blocks only concurrent commits, but not reader threads, since versions 
are immutable. After all data items are locked, the transaction validates itself by checking whether any other transaction
has committed on the locked items since it has started. This is done by comparing whether the latest commit timestamp
is larger than bts. If true, the transaction detected a write-write conflict, which leads to an abort. 