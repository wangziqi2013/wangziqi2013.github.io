---
layout: paper-summary
title:  "BCC: Reducing False Aborts in Optimistic Concurrency Control with Low Cost for In-Memory Databases"
date:   2018-06-25 19:06:00 -0500
categories: paper
paper_title: "BCC: Reducing False Aborts in Optimistic Concurrency Control with Low Cost for In-Memory Databases"
paper_link: https://dl.acm.org/citation.cfm?id=2904126
paper_keyword: BCC; OCC
paper_year: VLDB Jan 2016
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

Optimistic Concurrency Control (OCC) is favored on modern hardware over traditional Tow-Phase Locking (2PL)
for its high degree of parallelism and lower communication overhead between processors. OCC features a three 
phased transaction execution. In the first phase, the read phase, transactions optimistically read data items
without global state modification, and buffer writes in their local storage. Buffered write operations are called 
"pre-write", and these pre-writes will not be made public until the later commit phase. Transactions may read
inconsistent data items should other transactions commit during their read phases. The original OCC algorithm
does not try to address this problem, and implicitly assumes that inconsistent data will only affect the write set,
but never the control flow. After the read phase, transactions enter the second phase, the validation phase. 
Before entering the validation phase, transactions acquire a global commit mutex to serialize commit operations. 
The actual serialization order is the order that transactions acquire this commit mutex. During the validation
phase, transactions compare their read sets with write sets of transactions that have committed while it is 
reading. This is achieved via a global timestamp counter. Transactions read the counter at the beginning of 
transaction, and fetch-and-increment the counter after acquiring the commit mutex as its commit timestamp. 
Transactions whose commit timestamp is between this range are possibly writing into the read set of the 
committing transaction, and are hence subject to serializability checking. We call these transactions the 
"overlapping transactions" in the following text. The serializability checking is performed by intersecting 
the read set of the committing transaction with the write sets of overlapping transactions. This requires 
O(n) sets operations where n is the number of overlapping transactions. If any of the intersection returns 
non-empty result, a Write-After-Read (WAR) violation has happened, and the committing transaction must abort.
The WAR dependency is considered a violation here, because it disagrees with the serialization order established 
by acquiring the commit mutex. If transaction T1 writes onto the read set of transaction T2, then the dependency 
dictates that T1 should be serialized after T2. Since OCC assumes that the direction of dependencies must agree 
with the direction of commit order, it is implied that T1 should commit after T2. In the above example however, if
T1 commits before T2, then the commit order is violated, and T2 must abort. On the other hand, if the validating 
transaction passes validation, then it enters the last phase, the write phase, in which all locallu buffered 
writes are flushed to the shared storage. The write set of the transaction is also archived with the commit 
timestamp of the transaction. Later transactions will use this archived write set to perform read validation.
The write set can only be garbage collected after all concurrenct reading transactions have exited. After the 
write phase, the commit mutex is also released.

OCC increases the degree of parallelism and reduces the amount of communication between processors by reading 
optimistically without locking in the read phase. There are, however, still problems that can plunge OCC's performance. 
The first problem is that OCC still validates pessimistically despite the optimistic read phase. Transactions in OCC
will eventually abort if they cannot commit/will be blocked by 2PL. The second problem is that OCC may introduce many
false aborts if contention is high. For example, OCC always aborts a transaction if its read set is overwritten by
another transaction during the read phase. This, however, is only a necesssary condition for dependency cycles, but
not sufficient. When the degree of contention is high, it is expected that many WAR dependency will be identified as 
potential sources of violations, and OCC will suffer from performance degradation.

In order to increase the robustness of OCC under high contention, as well as to improve OCC's flexibility, this paper 
proposes Balanced Concurrency Control (BCC) as an alternative of OCC under high contention. BCC extends the execution 
model of OCC by allowing transactions having WAR dependencies to commit under certain circumstances. Accordingly, 
