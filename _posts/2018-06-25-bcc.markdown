---
layout: paper-summary
title:  "BCC: Reducing False Aborts in Optimistic Concurrency Control with Low Cost for In-Memory Databases"
date:   2018-06-25 19:06:00 -0500
categories: paper
paper_title: "BCC: Reducing False Aborts in Optimistic Concurrency Control with Low Cost for In-Memory Databases"
paper_link: https://dl.acm.org/citation.cfm?id=2904126
paper_keyword: BCC; OCC
paper_year: VLDB Jan 2016
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

Optimistic Concurrency Control (OCC) is favored on modern hardware over traditional Tow-Phase Locking (2PL)
for its high degree of parallelism and lower communication overhead between processors. OCC features a three 
phased transaction execution. In the first phase, the read phase, transactions optimistically read data items
without global state modification, and buffer writes in their local storage. Buffered write operations are called 
"pre-write", and these pre-writes will not be made public until the later commit phase. Transactions may read
inconsistent data items should other transactions commit during their read phases. The original OCC algorithm
does not try to address this problem, and implicitly assumes that inconsistent data will only affect the write set,
but never the control flow. After the read phase, transactions enter the second phase, the validation phase. 
Before entering the validation phase, transactions acquire a global commit mutex to serialize commit operations. 
The actual serialization order is the order that transactions acquire this commit mutex. During the validation
phase, transactions compare their read sets with write sets of transactions that have committed while it is 
reading. This is achieved via a global timestamp counter. Transactions read the counter at the beginning of 
transaction, and fetch-and-increment the counter after acquiring the commit mutex as its commit timestamp. 
Transactions whose commit timestamp is between this range are possibly writing into the read set of the 
committing transaction, and are hence subject to serializability checking. We call these transactions the 
"overlapping transactions" in the following text. The serializability checking is performed by intersecting 
the read set of the committing transaction with the write sets of overlapping 