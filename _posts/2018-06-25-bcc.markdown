---
layout: paper-summary
title:  "BCC: Reducing False Aborts in Optimistic Concurrency Control with Low Cost for In-Memory Databases"
date:   2018-06-25 19:06:00 -0500
categories: paper
paper_title: "BCC: Reducing False Aborts in Optimistic Concurrency Control with Low Cost for In-Memory Databases"
paper_link: https://dl.acm.org/citation.cfm?id=2904126
paper_keyword: BCC; OCC
paper_year: VLDB Jan 2016
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

Optimistic Concurrency Control (OCC) is favored on modern hardware over traditional Tow-Phase Locking (2PL)
for its high degree of parallelism and lower communication overhead between processors. OCC features a three 
phased transaction execution. In the first phase, the read phase, transactions optimistically read data items
without global state modification, and buffer writes in their local storage. Buffered write operations are called 
"pre-write", and these pre-writes will not be made public until the later commit phase. Transactions may read
inconsistent data items should other transactions commit during their read phases. The original OCC algorithm
does not try to address this problem, and implicitly assumes that inconsistent data will only affect the write set,
but never the control flow. After the read phase, transactions enter the second phase, the validation phase. 
Before entering the validation phase, transactions acquire a global commit mutex to serialize commit operations. 
The actual serialization order is the order that transactions acquire this commit mutex. During the validation
phase, transactions compare their read sets with write sets of transactions that have committed while it is 
reading. This is achieved via a global timestamp counter. Transactions read the counter at the beginning of 
transaction, and fetch-and-increment the counter after acquiring the commit mutex as its commit timestamp. 
Transactions whose commit timestamp is between this range are possibly writing into the read set of the 
committing transaction, and are hence subject to serializability checking. We call these transactions the 
"overlapping transactions" in the following text. The serializability checking is performed by intersecting 
the read set of the committing transaction with the write sets of overlapping transactions. This requires 
O(n) sets operations where n is the number of overlapping transactions. If any of the intersection returns 
non-empty result, a Write-After-Read (WAR) violation has happened, and the committing transaction must abort.
The WAR dependency is considered a violation here, because it disagrees with the serialization order established 
by acquiring the commit mutex. If transaction T1 writes onto the read set of transaction T2, then the dependency 
dictates that T1 should be serialized after T2. Since OCC assumes that the direction of dependencies must agree 
with the direction of commit order, it is implied that T1 should commit after T2. In the above example however, if
T1 commits before T2, then the commit order is violated, and T2 must abort. 