---
layout: paper-summary
title:  "Reduced Hardware NORec: A Safe and Scalable Hybrid TRansactional Memory"
date:   2019-11-02 17:59:00 -0500
categories: paper
paper_title: "Reduced Hardware NORec: A Safe and Scalable Hybrid TRansactional Memory"
paper_link: 
paper_keyword: HTM; STM; NORec; Hybrid TM
paper_year: ASPLOS 2015
rw_set: Hybrid
htm_cd: Hybrid
htm_cr: Hybrid
version_mgmt: Hybrid
---

This paper presents hardware NORec, a hybrid transactional memory design based on the lightweight NORec. The paper identifies
that some aspects in STM design will cause slowdown of execution, making single thread performance of STM several times slower
than non-instrumented execution. For example, NORec requires every transactional load and store be instrumented, in order 
to maintain a read and write set for the transaction. This causes notable instruction explosion and metadata overhead, which
decreases both the IPC due to excessive cache misses (both icache and dcache since instruction traces are also larger),
and instruction throughput. What is more, the conflict resolution protocol in NORec relies on a single atomic global counter
serving as the serialization point for concurrent transaction. A reader transaction must check the counter on every transactional
load to maintain opacity. If the check fails, meaning that the transaction may access inconsistent data, it must abort 
and retry.

Hardware NORec is based on NORec, a previously proposed pure software TM scheme. NORec eliminates the requirement for 
having a direct-mapped or hashed metadata field for every accessing unit (i.e. the unit of version management and conflict
detection) by using a global counter for serialization, and by using value validation. The global counter is consists of 
two fields. The first one bit field on the highest bit is a lock bit, which indicates whether some transaction is currently 
committing. The second field is a version field, which indicates the current read version, which is also the most up-to-date 
committed version. The counter is stored in globally accessible memory as a properly aligned machine word, such that the 
value of the counter can be loaded and atomically swapped using special instructions in the ISA. NORec works as follows. 
First, on transaction begin, the transaction reads the global counter and saves its value into a local variable as the 
local counter. Then, for every read operation, the instrumented code loads the value from memory, and checks whether the 
current value of the clock equals the local counter, and that whether the global clock is unlocked. If true, then the read 
succeeds, because at the time of the read (actually slightly longer, since the check is performed after the load), no
transaction has committed yet. Otherwise, the transaction must either abort, or perform value-based validation. The 
value read by load instructions must also be stored in a read log in order to be later used by value validation. On transaction
writes, the value is inserted into a local write log, which is not published to shared memory until transaction commit.
On transaction commit, the transaction first locks the global clock by atomically swapping and setting the locked bit.
Then a value validation is performed, if (1) the transaction is not read-only; and (2) the value of the global clock
does not equal the value of the local counter (i.e. some transactions have committed). The value validation process iterates 
over the read log, and compares whether the value in the read log equals the current value in shared memory. Validiation 
succeeds if all values are idientical. The transaction finally commits by writing back all entries in the write set to 
the shared memory. The global lock is released atomically with the clock value incremented by one. The last step can be 
done by a single store instruction since on most platforms, an aligned store instruction is atomic. Note that all value
validations except the last one can be non-atomic, i.e. they can tolerate concurrent committing transactions as long as 
the value does not change, since a non-atomic value validation only validates the transaction at the logical time
of the first read issued as the validation check. For the last validation, concurrent committing transactions must be blocked,
since we must guarantee that the transaction is valid during the entire write stage. Otherwise, a committing transaction may
overwrite an item X read by the transaction, which is later written by the transaction, causing a dependency cycle as the 
current transaction is serialized before the committing transaction by not observing its write, but in the meantime also
serialized after that transaction by overwriting its write.
