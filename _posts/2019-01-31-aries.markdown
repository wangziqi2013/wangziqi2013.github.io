---
layout: paper-summary
title:  "ARIES: Atransaction Recivery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging"
date:   2019-01-31 22:26:00 -0500
categories: paper
paper_title: "ARIES: Atransaction Recivery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging"
paper_link: https://dl.acm.org/citation.cfm?id=128770
paper_keyword: ARIES; Recovery; Logging
paper_year: TODS 1992
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
--- 

This 69 page paper describes Algorithm for Recovery and Isolation Exploiting Semantics (ARIES) in great detail. ARIES 
is designed for providing durability to database transactions with fast recovery and low runtime overhead. ARIES also
requires less software engineering effort to adopt for an existing system, because it supports rich semantics and most
main stream database designs (as of the time the paper was published). We next describe the data structures and operations 
of ARIES.

ARIES requires two in-memory data structures to be maintained in the runtime. These two data structures are transaction
table (TT) which describes the commit state of transactions, and dirty page table (DPT). Neither of them is persisted 
to the disk except for performing checkpoints. During recovery, these two tables are recoverd by replaying log records 
since the last checkpoint. The transaction table, as stated above, stores information of currently active transactions
and their logging status. Typical fields include the transaction's commit progress (not yet committed, or waiting for log
records to be persisted), last log record written, and the next log record to undo if the transaction is halfway through
a partial or full rollback. The dirty page table stores information for dirty pages currently in the buffer pool. ARIES
only requires one field, the RecLSN (Recovery LSN), which is the smallest serial number of the log record that modifies the
page since the last write back of the same page. During normal processing, the entry is updated to the log record 
number whenever a page is loaded into the buffer pool for writing, or when a write operation causes the buffer pool 
entry to become dirty. If a page is evicted from the buffer pool, the corresponding entry is removed. During recovery,
however, the content of DPT does not strictly replicate the DPT before the failure. The reasoning behind is that ARIES
always use log entries as the ultimate reference for performing recovery. DPT, on the other hand, only acts as a filter 
that prevents most unnecessary I/O when they are truly avoidable. False positives are possible, but they only affect 
recovery speed instead of correctness.

ARIES maintains all log entries in a logically serial log. The actual implementation may partition the serial log into
multiple files. Each log entry has a Log Serial Number (LSN), which uniquely identifies: (1) The identity of the entry, and 
(2) The location of the entry in the log, which means that the content of the log entry can be found given the LSN. 
The LSN grows monotonically in all circumstances. A log entry may contain different information depending on its type.
We list them as follows. First, the log entry contains the entry's LSN, type and Transaction ID. These three fields
are common to all log entries. Most log entries also have a PrevLSN field, which stores the LSN of the previous log entry
written by the same transaction. The recovery routine could undo all uncommitted changes of a certain transaction by
repeatedly following the PrevLSN until a NULL value is seen, without having to scan the entire log. If the log entry
describes the modification to a page, it also has a page ID field, which stores the address that the modification is 
applied to. For log records generated during a rollback, a field UndoNextLSN stores the LSN of the next log entry that 
should be rolled back. This simplifies handling of transaction rollbacks, because the recovery routine only needs to 
use the most up-to-date entry to determine the next log entry from the same transaction that should be undone instead
of scanning the log backwards. The last field of log entries is data. For normal write operations during normal processing,
this field should contain both redo and undo information. For some log records, only redo information is present because 
they are part of the undo process, and cannot be undone.

We then describe the operations of ARIES during normal operation. The ARIES paper assumes a lock-based transaction management 
system, but also claims that ARIES does not preclude other design options. In either case, transactions must acquire 
latches on the page if they wish to insert or modify an element on the page. This is because data modification may incur
garbage collection or page reorganization, which requires mutual exclusion on the page. The log record can only be appended 
to the log while the page latch is held by the modifying transaction. This is to ensure that, for every page, the order of 
log records is consistent with the order of actual page modifications happening physically. If this property is violated,
it is possible that two log records on the same page are written out-of-order. During redo phase, these two entries will
then be applied also in the wrong order, causing data corruption in some cases (e.g. redo logging is operational). While appending
the log, the transaction manager computes the pre- and after-image of the data item to be modified, and fills in the 
PrevLSN field with the previous LSN the transaction has written (using the entry in the transaction table). On each 
persistent page, ARIES also maintains a LSN field called PageLSN. This field is updated whenever a log entry is generated
for that page, and will be written back to disk with the page (the easiest way is to make the field part of the page).
When the buffer pool decides to evict a page, according to the WAL property, log entries upto the entry that modifies the 
page must be written back before the page. In this case, the buffer pool manager reads the PageLSN field, and writes back
all log entries upto the one indicated by the PageLSN.

On transaction commit, the transaction manager appends a commit record to the log. To ensure durability, it also must 
write back all log entries the current transaction has written. Similar to the normal operation case, the transaction 
manager reads the transaction table to determine the last log entry the transaction generated. It then forces log 
entries upto the last LSN to be written back. The transaction could successfully commit after that. Note that ARIES
makes very relaxed assumption about the buffer manager: Buffer pool can be managed as steal, no-force. Steal means
dirty pages are allowed to be written back before the corresponding transaction commits. The undo log entry can help
recover to the previous state if crash happens. No-force means the transaction manager does not force dirty pages
to be written back to disk on transaction commit. As we have shown above, only log entries the transaction has written
will be written back. I/O is often significantly faster in this case, because writing the log only involves sequential I/O,
while writing disk pages is more random.

On a partial or full rollback, the transaction manager needs to undo the partial change the current transaction has performed
on disk pages. In ARIES, undo operations also generate log records, called Compensation Log Records (CLR). CLRs guarantee 
that every write operation can at most be undone once. Imagine the case where a transaction is halfway through a rollback
before the system crashes. If no CLR is generated, the recovery routine has no way to know at which point the rollback
operation was on at the moment of crash. Some operations in the log have to be undone twice in order to roll back the entire
transaction as part of the undo pass. As we will show