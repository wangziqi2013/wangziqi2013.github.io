---
layout: paper-summary
title:  "Project PBerry: FPGA Acceleration for Remote Memory"
date:   2019-11-13 12:27:00 -0500
categories: paper
paper_title: "Project PBerry: FPGA Acceleration for Remote Memory"
paper_link: https://dl.acm.org/citation.cfm?id=3321424
paper_keyword: FPGA; Remote Memory
paper_year: HotOS 2019
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Project PBerry, an FPGA accelerated scheme for implementing efficient remote memory. The paper identifies
two major problems of current implementation of distributed remote memory, which is based on software handling of page faults
and demand paging. The first problem is write amplification. When a remote page is evicted out of the current host's main
memory, it needs to be transferred to the remote machine in the granularity of a page. This is because current hardware 
does not support cache line level dirty data tracking, while page level tracking is implemented in the MMU by setting 
the "dirty" bit in the page table entry before a store instruction accesses the page. If only a few cache lines are modified
in the page before it is evicted, it is a waste of bandwidth to transfer the entire page to remote host. The paper 
suggests that for certain workloads, the majority of pages have less than 7 dirty cache lines. The second problem is 
software overhead for handling remote pages. Two page faults are required to handle a remote page correctly: one to 
trigger the transfer of the remote page (after which the page is write-protected), and another to release the write 
protection on the page after adding it to the write set. The second page fault is necessary, since user level remote memory 
libraries have no permission to access the page table. 

Project PBerry assumes a cache coherent FPGA with a hardware component that can either be configured to be a memory
controller handling requests to and from upper level hierarchiy, or as a cache controller which maintains cache line
states collectively with other bus agents on the network. The FPGA is connected to the system bus via one of the 
implementations of bus protocols. The paper proposes two schemes for connecting the FPGA Module (PBF) to the 
system bus. In the first scheme, the PBF acts as a memory controller, which snoops on cache line evictions from
upper level caches. At system startup time, part of the physical address space is mapped to this FPGA device, such that
upper level controllers will send cache lines mapped to this address range to the FPGA device rather than regular controller
(or rely on snooping? I am not an expert on this, so I assume upper level cache controllers either "know" which address
is mapped to which destination, or they put the address on a broadcasting bus, and wait for lower level devices
to take the responsibility). 
The OS is also configured such that remote pages are mapped to this physical address range. The FPGA device stores 
evicted cache lines in its internal memory, and tracks the metadata (e.g. tags, sizes) in a buffer accessible to the OS.
When an evicted line is received on the controller, 