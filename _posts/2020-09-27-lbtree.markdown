---
layout: paper-summary
title:  "LB+-Trees: Optimizing Persistent Index Performance on 3DXPoint Memory"
date:   2020-09-27 03:50:00 -0500
categories: paper
paper_title: "LB+-Trees: Optimizing Persistent Index Performance on 3DXPoint Memory"
paper_link: https://dl.acm.org/doi/10.14778/3384345.3384355
paper_keyword: NVM; B+Tree; LB-Tree
paper_year: VLDB 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents LB-Tree, or Line Write/Logless B+Tree, a NVM optimized B+Tree design for efficient updates.
Although not explicitly stated, the paper identifies a few inefficiencies in conventional in-memory B+Tree designs
when ported to the NVM, such as ordered nodes, the overhead of structural modifications, and maintaining consistent
node states.

The paper makes three critical observations that enable extra optimizations on NVM. First, it is observed that the 
performance of NVM writes of a cache line does not depend on the number of dirty bits in the cache line. Theoretically
speaking, NVM may adopt optimizations to minimize the number of flipping bits in each internal writes, to reduce the 
number of physical state changes. This optimization is not present in the current commercial product, most likely because
the NVM device encrypts data stored in the physical array, in which case a single bit change in the input line will
propagate to the remaining bits, offsetting the benefits of the optimization. This observation suggests that B+Tree
designs may perform extra writes in addition to the requested one if these extra writes lower the overhead of the following
updates. 
The second observation is that NVM internal units of reads and writes are 256 bytes, meaning that all reads and writes
are performed internally with 256-byte persistent buffers despite the 64-byte memory interface. 
As a result, reads to aligned 256-byte data can achieve higher bandwidth, since the internal buffer can sustain higher
bandwidth than accessing the physical array. Similarly, writes to aligned 256-byte data are also faster.
The last observation is that the performance of NVM device also depends on storage utilization. The performance of a
new device drops until the working set size grows exceed one eighth of the device capacity. Although this property
does not affect the design directly, it indicates that testing should use at least one eighth of device storage in order
to be cover all cases.

Overall, LB-Tree leverages the following techniques to make writes efficient. First, elements in leaf nodes are not sorted,
since maintaining the ordering property of leaf nodes will involve shifting existing elements in the node, causing massive,
multi-line updates. Instead, elements can be stored anywhere in the leaf node, even leaving gaps between two valid 
elements. A bitmap in the node header tracks which slots are occupied and which are empty. Insert operations, therefore,
can just select an empty slot using the bitmap, and fill key and value into the slot.
Search operations on leaf nodes, as a result, must scan the node linearly, skipping invalid slots using the bitmap.


