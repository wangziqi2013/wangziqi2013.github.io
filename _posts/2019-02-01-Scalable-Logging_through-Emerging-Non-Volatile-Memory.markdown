---
layout: paper-summary
title:  "Scalable Logging Through Emerging Non-Volatile Memory"
date:   2019-02-01 17:27:00 -0500
categories: paper
paper_title: "Scalable Logging Through Emerging Non-Volatile Memory"
paper_link: https://dl.acm.org/citation.cfm?id=2732960
paper_keyword: ARIES; Recovery; Logging; NVM
paper_year: VLDB 2014
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---  

This paper proposes distributed logging, a mechanism that extends ARIES-stype database recovery algorithm
to provide support for scalable logging on multicore. The traditional ARIES algorithm provides a general-purpose, efficient,
and versatile solution for database recovery, which requires only simple data structures and a few extension to an existing
database system. The core of ARIES is a software maintained sequential log, in which log entries of different types
are stored. Log entries are identified by their unique Log Sequence Number (LSN), which corresponds to their logical 
offsets into the log. Although not explicitly mentioned in the paper, in order to append an entry into the log, the 
transaction should acquire both a page latch and a log latch. The former is to ensure that two different transactions
modifying the same page should append their entries in the same order as they conduct the modification. The latter is to
protect the integrity and consistency of the log itself, preventing concurrent modifications corrupting the log data 
structure. 

To reduce I/O overhead, log entries are only written back to the disk in large batch, which must follow the Write-Ahead
Logging (WAL) property. The WAL property defines two types of write ordering. First, when a dirty page is to be written
back to the disk, the log entry that wrote the page must be written back before the page. ARIES enforces this write 
ordering by forcing a log flushing till the LSN which is the most recent entry that modifies the page. The second write 
ordering is that before a transaction can write its commit record, all log entries generated by that transaction must be 
written back to the disk. ARIES enforces all log entries up to the transaction's most recent to be written back in this case.
To further amortize the overhead of frequently scheduling disk I/O, the transaction manager could choose to group commit
a batch of transactions rather than committing them individually. Instead of writing the log entries for a transaction
immediately when a transaction finishes execution, the transaction manager puts the completing transaction into a t
commit pending queue. Transactions in the pending queue are only committed if the queue is full, or there has not been
any commit for a while. With group commit, only one large I/O operation is scheduled for all transactions in the pending 
queue, which amortizes the overhead of I/O over multiple committing transactions at the cost of longer commit latency. 

Beging able to write into a centralized log object in the DRAM simplifies logging logic, because all log entries have 
a unique LSN, and their logical ordering is implied by the LSN. During recovery, ARIES does not redo a log entry, 
if the log LSN is smaller than or equal to the last modified LSN recorded on the page. On the other hand, however,
keeping a centralized object in the memory which is accessed using a lock can easily become a performance bottleneck
on today's multicore architecture. The situation is only aggravated as the number of cores in the system increases
and with multi-node memory architecture such as NUMA. 

To overcome the inherent shortcoming of centralized logging, this paper proposes distributed logging which allows multiple
log objects to be maintained in the main memory following some partitioning rules. In addition, recovery can be made more 
efficient using multiple log objects by adopting concurrent recovery algorithms. The paper also takes advantage of the fact 
that with the advent of Non-Volatile Memory (NVM), even random I/O from or into the NVM will be much faster than sequential 
I/O with disks. This observation justifies multiple log objects, which will incur non-sequential I/O operation to the NVM
address space.