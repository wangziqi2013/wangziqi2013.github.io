---
layout: paper-summary
title:  "Unbounded Hardware Transactional Memory for a Hybrid DRAM/NVM Memory System"
date:   2020-12-10 05:18:00 -0500
categories: paper
paper_title: "Unbounded Hardware Transactional Memory for a Hybrid DRAM/NVM Memory System"
paper_link: https://www.microarch.org/micro53/papers/738300a525.pdf
paper_keyword: NVM; HTM; UHTM
paper_year: MICRO 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

**Lowlight:**

1. The paper lacks many details that are necessary to judge its feasibility. For example:
   (1) Where is the per-core bloom filter placed? LLC or L1? LLC would be a better place since a request only knows 
       that it misses the hierarchy at LLC. Also, inserting into the filter is easier on LLC evictions.
   (2) When a block is evicted from the LLC, how are bloom filters updated? Do we insert into read set for those
       that are in the sharers list, and insert into write set for the one that are in the owner list?
   (3) In the above scenario, what if one of the sharers or the owner is currently switched out (so its
       bloom filter is not loaded)? Do we invoke OS and let OS find its bloom filter?

2. This paper assumes inclusive LLC, such that cache lines not in the LLC will definitely not in upper level caches.
   This is may not be true for large multicores.
   And even if this assumption is valid, the author should explicitly put it in the text.

3. What if an address is first evicted into the LLC / DRAM, and then read back again? Do we delete it from the overflow
   list, or just let it stay in the list?

4. Are transactions required to be pinned on the same core until finish? It seems to me that this is not required
   since on page 9, "Context Switch" section, it is suggested that transaction abort should broadcast the aborted
   transaction ID to all cores. But in this case, how do you make speculative lines non-speculative, when a 
   transaction commits at a different core?

5. Speculative cache lines are not tagged with transaction ID to indicate the ownership. On commit or abort, how do you
   know which line belongs to which transaction?

This paper proposes Unboundes HTM (UHTM), a HTM design for hybrid DRAM/NVM architecture.
The paper points out that prior HTM prosals are unable to handle modern workloads on NVM-based architecture for 
several reasons.
First, due to the fact that NVM has higher storage density than DRAM, NVM devices can store much more data in the
same area, and therefore, applications running NVM workloads tend to have significantly larger memory footprint
than DRAM transactions. This puts a heavy burden on version management, which distinguishes speculative copies of
data from the committed image. Prior researches either assume a bounded HTM model, in which transactions will be 
aborted when speculative states overflow the last-level cache (LLC), or assumes unbounded model, and employ logging
or other heavy-weight techniques to maintain speculative versions of data.
Second, conflict detection between parallel transactions can severely hamper the usability of an HTM design.
Most proposals rely on cache coherence to provide read and write information. Some of them assume a fully-mapped
directory, in which one entry is reserved for each cache line sized block in physical memory. This is not applicable,
since NVM is typically much larger than DRAM, and the storage overhead of directory entries (whcih, for minimum 
latency, must be maintained in DRAM) would be huge compared with DRAM size. On the other hand, some other designs
use bloom filters or other address signatures to track the approximate read and write set, and rely on simple
bit operations between these signatures to detect conflict. These approaches suffer from very high false positive
rates, which can also render the design unusable when the size of the working set is large.

UHTM solves the above issues with a combination of different techniques. To deal with version management for both NVM 
and DRAM, the paper proposes that logging be used when speculative lines overflow from the LLC. For addresses mapped to
the DRAM, the DRAM controller performs undo logging before applying the update in-place, such that when a power loss
occurs, the speculative content of the DRAM can be rolled back automatically. In addition, commit operations on the DRAM
are fast, since the controller simply truncates the log.
For addresses mapped to the NVM, the paper proposes that speculative states are written in the form of redo logs, which 
are persisted to the NVM when dirty lines are evicted from the LLC.
Using redo logs, however, suffers from long log search latency when the most up-to-date values are to be accessed later.
To address this issue, the paper further proposes that an L4 DRAM cache be added between the LLC and the NVM.
Speculative states evicted from the LLC are not only written to the NVM as redo logs, but also update the DRAM cache,
such that future accesses are likely to hit the cache, saving both log traversal latency and NVM access bandwidth.

To deal with conflict detection overheads and false positives, the paper proposes a two-stage conflict detection 
protocol, where both the directory and address signatures are used. When the address to be accessed is in the cache
hierarchy, an access request is checked against the LLC's directory for conflicting accesses. This ensures that 
conflicts of cache lines in the hierarchy can be detected with normal access latency, which covers the majority of 
cases. The processor also maintains two per-core address signatures, one for read set and another for write set. 
Cache lines evicted from the LLC are inserted into the signatures for all accessing transactions. 
If the address to be accessed is not in the hierarchy, the requested address is then checked with all signatures,
and conflicts are signaled if one of the signature indicates that the address is present.
Since most conflicts are already resolved in the hierarchy with the directory, and that only overflowing addresses
are inserted into the signature, UHTM can achieve a lower false positive rates on the signature than prior proposals.

UHTM extends the cache hierarchy as follows. For each cache line, one speculative bit tracks whether the line
has been read or written by a transaction. This bit serves as an indicator to the LLC controller that the line
belongs to a transaction, has not yet been logged, and that special actions must be taken when it is evicted.
Second, for each core, two bloom filters are added to represent the working set currently not in the cache hierarchy,
one for read set, and another for write set. The LLC controller inserts evicted lines into the corresponding bloom
filters of cores that have read or written the line during a transaction. 
Note that the bloom filters are not updated when a line is fetched from the DRAM or NVM, at which time these lines
are treated as non-speculative lines. This does not affect correctness, since lines are logged for off-core commit
or abort the moment they were evicted.

The third hardware change is that each LLC directory entry is extended with extra fields for tracking speculative
readers and writers. Each transaction is allocated a unique transaction ID at the beginning, and LLC's directory
stores transaction IDs for transactions that have speculatively accessed the line. For each cache line, at most
one speculative writers, or multiple speculative readers are allowed, but not both.

