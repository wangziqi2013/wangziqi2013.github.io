---
layout: paper-summary
title:  "Pronto: Easy and Fast Persistence for Volatile Data Structures"
date:   2020-08-26 18:39:00 -0500
categories: paper
paper_title: "Pronto: Easy and Fast Persistence for Volatile Data Structures"
paper_link: https://dl.acm.org/doi/10.1145/3373376.3378485
paper_keyword: NVM; Pronto; Logical Logging
paper_year: ASPLOS 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Pronto, a software library for transforming existing data structures implemented on volatile memory
to their non-volatile counterparts. The paper points out that the current trend of implementing non-volatile data structures
either use libraries to denote failure-atomic regions, or develop ad-hoc algorithms to support persistence.  In order to denote failure-atomic regions, the programmer needs to take an existing
data structure implementation, and instrument all memory writes with library calls. This can be tedious, errorneous, and 
most importantly, it is not always possible to instrument all memory writes, due to the usage of third-party libraries.
On the other hand, designing an ad-hoc data structure requires large amount of work on debugging and verification. 
In practice, neither approach works very well.

Pronto solves the above issue with a combination of semantics logging, background persisting threads, and periodic 
checkpointing. Instead of logging every data update within the failure-atomic region, requiring persistence
barriers for each update, Pronto only persists the logical operation and their parameters to the NVM. Recovery is performed
by re-executing these invocations in the logical serialization order, bringing the memory state of the data structure to
the pre-crash state.
To avoid executing the persisting barrier for the per-invocation log entry, Pronto proposes that background threads be 
used to overlap persistence with execution. Thanks to semantic logging, the only write ordering that must be observed
by the persisting thread and the executing thread is when the operation completes, the function must return after the 
log entry is persisted. This enables the background thread to persist the log entry at any point during execution, unlike 
undo or logging, where a per-store write ordering must be observed, blocking store operations until a log entry is 
persisted. 
Checkpointing is also employed to reduce recovery overhead and perform garbage collection on the semantic log. 
Periodically, the background checkpointing thread saves the current consistent image of the working set to the NVM. 
Recovery can simply start from the most recent checkpointed state, and only re-execute log entries generated after the 
checkpoint.