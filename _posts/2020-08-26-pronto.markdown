---
layout: paper-summary
title:  "Pronto: Easy and Fast Persistence for Volatile Data Structures"
date:   2020-08-26 18:39:00 -0500
categories: paper
paper_title: "Pronto: Easy and Fast Persistence for Volatile Data Structures"
paper_link: https://dl.acm.org/doi/10.1145/3373376.3378485
paper_keyword: NVM; Pronto; Logical Logging
paper_year: ASPLOS 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

**Lowlights:**

1. `op_commit()` should be the point that log entries are generated and persisted, rather than `op_begin()`, since log entries
   must be written in one of the the valid serialization orders. The order can only be determined when the serialization
   point is attained, e.g. after all locks are acquired in 2PL or after the write set is locked in OCC.
   If persistence begins at `op_begin()`, it is still unknown the ordering of the log entry, since two concurrent operations
   sharing at least one lock in the 2PL example will race on `op_begin()`, but not race on `op_commit()`.
   Even in the example of concurrent `unordered_set` given in the paper, it is possible that operation A executes `op_begin()`
   first, but acquires lock L later, while operation B executes `op_begin()` after A, but acquires the lock earlier.
   In this example, the ordering of the two log entries (A > B) are, in fact, inconsistent with their logical ordering 
   (B > A)

This paper presents Pronto, a software library for transforming existing data structures implemented on volatile memory
to their non-volatile counterparts. The paper points out that the current trend of implementing non-volatile data structures
either use libraries to denote failure-atomic regions, or develop ad-hoc algorithms to support persistence.  In order to denote failure-atomic regions, the programmer needs to take an existing
data structure implementation, and instrument all memory writes with library calls. This can be tedious, errorneous, and 
most importantly, it is not always possible to instrument all memory writes, due to the usage of third-party libraries.
On the other hand, designing an ad-hoc data structure requires large amount of work on debugging and verification. 
In practice, neither approach works very well.

Pronto solves the above issue with a combination of semantics logging, background persisting threads, and periodic 
checkpointing. Instead of logging every data update within the failure-atomic region, requiring persistence
barriers for each update, Pronto only persists the logical operation and their parameters to the NVM. Recovery is performed
by re-executing these invocations in the logical serialization order, bringing the memory state of the data structure to
the pre-crash state.
To avoid executing the persisting barrier for the per-invocation log entry, Pronto proposes that background threads be 
used to overlap persistence with execution. Thanks to semantic logging, the only write ordering that must be observed
by the persisting thread and the executing thread is when the operation completes, the function must return after the 
log entry is persisted. This enables the background thread to persist the log entry at any point during execution, unlike 
undo or logging, where a per-store write ordering must be observed, blocking store operations until a log entry is 
persisted. 
Checkpointing is also employed to reduce recovery overhead and perform garbage collection on the semantic log. 
Periodically, the background checkpointing thread saves the current consistent image of the working set to the NVM. 
Recovery can simply start from the most recent checkpointed state, and only re-execute log entries generated after the 
checkpoint.

Pronto is implemented as a C++ class, `PersistentObject`, serving as the base class of data structure types. 
The two most important methods of the class are `op_begin()` and `op_commit()`, which generates a semantic log entry and 
persists the entry to the NVM respectively. 
Programmers can just take an existing data structure class, make it a subclass of `PersistentObject`, 
override methods whose effects should be persistent with a wrapper function, and call `op_begin()`, `op_commnt()` in
in wrapper function. 
In all cases, `op_begin()` is inserted at the beginning of the function, taking the function pointer and arguments
to the wrapper as parameters. Internally, a semantic log entry with the value of the method pointer and its
arguments are generated, and dispatched to the background thread for persistence.
`op_commit()`, on the contrary, synchronizes the execution thread with the persisting thread, the effect of which is 
similar to how write ordering is enforced using persistenct barriers. 
Serial operations can just insert `op_commit()` at the end of the wrapper before it returns, while parallel data 
structures should make sure that the order of entries in the semantic log is consistent with the logical ordering of 
the real-time execution. For example, the paper suggests that, for data structures using 2PL, `op_commit()` should be 
called right after all locks have been acquired, when 2PL attains the serialization point.
