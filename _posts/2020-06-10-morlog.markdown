---
layout: paper-summary
title:  "MorLog: Morphable Hardware Logging for Atomic Persistence in Non-Volatile Main Memory"
date:   2020-06-10 12:33:00 -0500
categories: paper
paper_title: "MorLog: Morphable Hardware Logging for Atomic Persistence in Non-Volatile Main Memory"
paper_link: https://www.iscaconf.org/isca2020/papers/466100a610.pdf
paper_keyword: Logging; Undo Log; Redo Log; MorLog
paper_year: ISCA 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes MorLog, a hardware logging scheme for providing atomic persistence to transactional NVM systems. 
Conventional undo and redo logging suffers from performance overhead from several aspects. First, undo logging requires 
enforing the write ordering between log entries and data on the same address, which would require eagerly flushing undo 
log entries before data is written in the cache, given that the cache controller may write back the cache line any monent 
after it becomes dirty. In addition, undo logging requires that dirty data be persisted on the NVM before a transaction 
commits, which can cause long commit latency. On the other hand, redo logging, though not need requiring flushing log 
entries before the commit point, should prevent dirty blocks from being written back before the transaction commits.
This is to avoid write backs of uncommitted data corrupting the consistent before-transaction image on the NVM.
Both schemes, if used naively in their canonical forms, require non-negligible changes to the cache controller and eviction
logic. Second, if not treated with care, it is easy to generate redundant log entries that are not useful for recovery,
but will take extra space on the NVM. For example, in undo logging, the actual useful log entry is the one taken on the 
first write since transaction begin. Later writes do not have to be logged, since the pre-image they record is merely
dirty data generated within the same transaction. Similarly, in redo logging, only the last write to an address should
be logged, if the address is updated multiple times. Previous redo log entries will be overwritten during recovery by
the last entry, rendering them totally useless and a waste of space. The last issue is log storage overhead and logging
granularity. For hardware logging, the most natural granularity of log genetation is a cache line, which will be included
as a fixed sized pre- or post-image field in the log entry. Cache lines, however, may only contain a few bytes of dirty 
data, making the writing of the clean bytes unnecessary. In addition, cache lines often contain replicative or redundant
data, making compression an attractive measure for reducing log storage, the opportunity of which was never explored 
before this paper.

Based on the above observation, this paper makes the following contributions. First, it implements mixed redo-undo 
logging by simultaneously generating both undo and redo log entries on an L1 write, which get rid of two write orderings. 
First, the cache no longer needs to be flushed on transaction commit, since dirty data has been persisted in the form
of redo log entries. Second, the cache no longer needs to hold dirty blocks without evicting them before transaction
commits, since undo log entries help restoring the pre-image of data even if the NVM image has been pollutedd by a
premature write back from the cache hierarchy. Two write ordering restrictions remain, however, to maintain the 
correctness of the algorithm. First, redo log entries still need to be written back on commit point to persist the 
transaction's working set. Second, undo log entries still have to be written before dirty block reaches the NVM.
The paper loosens the second ordering restriction a little by taking advantage of the minimum number of cycles it will 
take a block to traverse through the cache hierarchy to reach NVM.

The second contribution of the paper is the eager-undo and lazy-redo log flushing scheme. As discussed in previous 
sections, only the first undo and the last redo log entries are actually useful for crash recovery. To leverage such
differences in the characteristics of logging, the paper adds two log buffers on-chip, one for mixed logging, and 
the other for redo only. Both undo and redo entries are generated into the mixed logging buffer on the first write to 
a clean L1 cache line. These entries are kept within the buffer for an extra N cycles to exploit possible chances
of log coalescing, in which subsequent writes may modify the same cache line, and these writes could just be incorporated
into an existing entry for the same line. The log entry is flushed back to the NVM after N cycles, where N is the 
minimum number of cycles it takes for a cache block from L1 to traverse thehierarchy and finally reach the NVM,
ensuring that the undo entry can always be written before dirty data.

