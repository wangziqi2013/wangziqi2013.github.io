---
layout: paper-summary
title:  "MorLog: Morphable Hardware Logging for Atomic Persistence in Non-Volatile Main Memory"
date:   2020-06-10 12:33:00 -0500
categories: paper
paper_title: "MorLog: Morphable Hardware Logging for Atomic Persistence in Non-Volatile Main Memory"
paper_link: https://www.iscaconf.org/isca2020/papers/466100a610.pdf
paper_keyword: Logging; Undo Log; Redo Log; MorLog
paper_year: ISCA 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes MorLog, a hardware logging scheme for providing atomic persistence to transactional NVM systems. 
Conventional undo and redo logging suffers from performance overhead from several aspects. First, undo logging requires 
enforing the write ordering between log entries and data on the same address, which would require eagerly flushing undo 
log entries before data is written in the cache, given that the cache controller may write back the cache line any monent 
after it becomes dirty. In addition, undo logging requires that dirty data be persisted on the NVM before a transaction 
commits, which can cause long commit latency. On the other hand, redo logging, though not need requiring flushing log 
entries before the commit point, should prevent dirty blocks from being written back before the transaction commits.
This is to avoid write backs of uncommitted data corrupting the consistent before-transaction image on the NVM.
Both schemes, if used naively in their canonical forms, require non-negligible changes to the cache controller and eviction
logic. Second, if not treated with care, it is easy to generate redundant log entries that are not useful for recovery,
but will take extra space on the NVM. For example, in undo logging, the actual useful log entry is the one taken on the 
first write since transaction begin. Later writes do not have to be logged, since the pre-image they record is merely
dirty data generated within the same transaction. Similarly, in redo logging, only the last write to an address should
be logged, if the address is updated multiple times. Previous redo log entries will be overwritten during recovery by
the last entry, rendering them totally useless and a waste of space. The last issue is log storage overhead and logging
granularity. For hardware logging, the most natural granularity of log genetation is a cache line, which will be included
as a fixed sized pre- or post-image field in the log entry. Cache lines, however, may only contain a few bytes of dirty 
data, making the writing of the clean bytes unnecessary. In addition, cache lines often contain replicative or redundant
data, making compression an attractive measure for reducing log storage, the opportunity of which was never explored 
before this paper.

