---
layout: paper-summary
title:  "Atlas: Leveraging Locks for Non-Volatile Memory Consistency"
date:   2019-08-04 01:07:00 -0500
categories: paper
paper_title: "Atlas: Leveraging Locks for Non-Volatile Memory Consistency"
paper_link: https://dl.acm.org/citation.cfm?id=2660224
paper_keyword: NVM; Critical Section; Undo Logging
paper_year: OOPSLA 2014
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper introduces Atlas, a runtime library for ensuring persistency on multi-threaded applications. This paper assumes 
that the program is written data race-free, using locks as the mathod of synchronization. The paper also assumes 
that the NVM device is attached to the memory bus, and can be allocated in user space via nv_malloc() calls which
maps a "persistent region" of user VA onto the device. Stores to the persistent region will not be immediately flushed to
the NVM device. Instead, they may remain in the cache as long as the cache controller does not evict the cache block
or the programmer does not issue a cache line flush instruction. In this situation, the library must ensure two invariants:
First, each individual critical section (and probably the resule of merging several critical section) should be atomic,
i.e. either all stores in that critical section is persisted, or none of them is persisted. This implies some form of 
logging, which has already been addressed in previous publications. Second, in the case of multiple nested critical
sections, extra care must be taken to avoid the system recovering to an inconsistent state, even if all individual
critical sections are recovered properly. To see the reason, assume there are two threads, T1 and T2. T1 is exeuting a 
critical section consisting of two lock acquires: lock(L1), lock(L2), Write(X), unlock(L1), unlock(L2), and T2 executes 
the following sequence: lock(L1), Read(X), Write(Y = X + 1), unlock(L1). We further assume that during the execution, T2 
executes lock(L1) after T1 releases L1, and the system crashes after T2 finishes unlock(L1) (and is persisted) but before 
T1 could unlock L2. In this example, since T1's critical has not yet finished execution, it must be rolled back during 
recovery to ensure the atomicity of the critical section. On the other hand, since T2 has been persisted on the NVM, if 
the recovery handler commits T2's critical section (i.e. make it persistent or not undo its changes), then essentially,
T2's critical section wrote a value from nowhere, since the source critical section where the value X is updated has 
been undone.

The paper first defines FASE (Failure-Atomic Section) as the minimum sequence of executed instructions by a thread in
which at least one lock is held for all instructions. This essentially flattens out nested locks, no matter whether 
they are perfected nested (like transactions in a TM) or not (like the 2PL protocol or hand-over-hand locking protocol
used in B+Trees). This suggests that state modifications within the FASE must be treated as a single logging unit.
In addition, if thread T2 synchronized with another thread T1 in the runtime (i.e. either unblocked by T1, or acquired 
a lock that was previously released by T1), then T2's critical section must logically commit after the corresponding 
critical section in T1. Note that due to nested critical sections, the release operation may be at the middle of a 
FASE. In this case, T2's FASE must be logically serialized after T1's FASE.