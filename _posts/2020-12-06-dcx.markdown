---
layout: paper-summary
title:  "Data Compression Transformations for Dynamically Allocated Data Structures"
date:   2020-12-06 19:37:00 -0500
categories: paper
paper_title: "Data Compression Transformations for Dynamically Allocated Data Structures"
paper_link: https://link.springer.com/chapter/10.1007/3-540-45937-5_4
paper_keyword: Compression; 
paper_year: LNCS 2002
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

**Lowlight:**

1. The paper proposes that pointer values can be compressed with a common prefix. But it never identified how the
   common prefix is maintained and stored, and what if the common prefix changes. Do we keep only one such prefix
   for all pointer values, or we can use multiple prefixes? Obviously the runtime should provide storage for
   keeping the prefix, such that the compression/decompression instructions have a way of using them in the
   instructions.

This paper proposes Data Compression Extension (DCX) instruction set extension for performing simple data compression
on heap-allocated data. Compared with conventional data compression approaches, where all cache lines in a certain
address range or all objects are compressed without distinction, the DCX proposal allows software to select certain 
fields as compression candidates, and only compresses these fields in the run-time, avoiding unnecessary overhead
of compression if applied to uncompressible data.

DCX is based on two observations. First, most pointer values to heap memory share common higher-order bits, since 
these memory blocks are typically created by an allocator that tend to group addresses that are close to each other
for better access locality. Besides, some systems have a hard constraint on higher-order bits of pointers, further
consolidating this observation.
Second, most integers values used in real-world workloads do not exploit all bits in a 32-bit integer (the paper assumes
32-bit integers and pointers). These integers can be compressed with less number of bits, as long as the higher-order
bits are identical to the sign bit after compression. The original value can be easily compressed restored without any
external information just by eliminating and replicating the sign bit respectively.

The compression algorithm proposed by this paper is simple, which aims at compressing pointer values and integers into
15-bit words. If two adjacent fields are both compressed in an object, these two fields can be represented with one
32-bit integer word, with each of the half words storing a compressed result. The highest bit of the compressed word
indicate whether the word stores two compressed words (set to "1", if true). The object is always allocated with the 
compressed word, hence consuming less memory. If, in the run-time, one or both of the compressed fields become 
uncompressable, then both values will be decompressed, and stored in a extra block of memory consisting of only two 
fields. This block of memory will be linked to the main object by using the compressed word as a pointer to the
block. 
