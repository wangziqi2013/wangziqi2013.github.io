---
layout: paper-summary
title:  "Efficient Hardware-assisted Logging with Asynchronous and Direct-Update for Persistent Memory"
date:   2019-01-15 23:02:00 -0500
categories: paper
paper_title: "Efficient Hardware-assisted Logging with Asynchronous and Direct-Update for Persistent Memory"
paper_link: 
paper_keyword: Redo Logging; Durability; NVM; Redu
paper_year: HPCA 2018
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes Redu, a transaction system that supports atomic durability using redo logs. Prior designs of 
transactional systems with durability must use one of the three logging schemes: (1) undo, where the before-image of the 
data item being modified is recorded in the log; (2) redo, where the after-image of the data item being modified is 
recorded in the log. In this case, the actual data item on NVM may not actually be modified, because the log 
is sufficient for reproducing the modifications; (3) redo + undo where both before- and after-image are saved 
in the log. This scheme allows more flexible handling of cache lines, because both uncommitted and committed 
transactions can be handled by the recovery routine using the log.

This paper claims that all the above three schemes are insiffucient to build a system that has both high throughput and 
low latency. For undo logging, since only the before-image is saved to the log, two types of write ordering must be observed. 
The first type is that the log write containing the before-image must be persisted before the updated data item. Otherwise,
if a crash happens right after the data item reaches NVM (at which time the log entry has not made it), there is no way
to recover from such failure since no undo image is present to roll back the changes. The second type of write ordering is that
on commit, all dirty updates in the cache must be persisted on the NVM before the application can be notified of the commit.
Otherwise, on a power loss, those committed dirty lines will be lost. Enforcing the two write orderings can have a negative 
effect on latency of both write and commit operations. For write operation, the log entry must circumvent the cache and be
flushed to the NVM before the store could proceed. This is usually done using a cache line write back instruction and 
a store fence. Similarly, on commit, all dirty cache lines are written back to the NVM using write back instructions and 
fences, which is even worse, because this operation is on the critical path of the commit sequence. 