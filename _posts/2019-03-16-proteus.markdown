---
layout: paper-summary
title:  "Proteus: A Flexible and Fast Software Supported Hardware Logging Approach for NVM"
date:   2019-03-16 21:39:00 -0500
categories: paper
paper_title: "Proteus: A Flexible and Fast Software Supported Hardware Logging Approach for NVM"
paper_link: https://dl.acm.org/citation.cfm?id=3124539
paper_keyword: NVM; Logging; Proteus
paper_year: MICRO 2017
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper presents Proteus, a hardware extension on NVM based architectures for supporting atomic durability. Prior to 
Proteus, past designs tend to either only focus on software side or on the hardware side. Software solutions require 
programmers or compilers to insert software persist barriers to enforce correct write ordering. For example, Intel provided 
programmers with a set of new instructions, called PMEM, to compose persist barriers on x86 based architectures. A persist
barrier using PMEM consists of one or more cache line flush instructions, and a pcommit instruction at the end. The cache 
line flush instructions make sure that all dirty states are written into the NVM controller, and pcommit guarantees that
NVM controller has drained its internal write queue. Dirty states generated before the barrier and flushed by the cache line 
flush instructions are guaranteed to be persistent on the NVM after the barrier returns. Store fences are also inserted 
to impose correct memory ordering between PMEM instructions and earlier store instructions. Though not requiring any expensive
hardware changes and can be deployed quickly, software barriers are overly conservative, and are slow and cumbersome to use. 
This is because programmers have no control over how cache lines are maintained by the hardware cache and how dirty lines 
are written back by the NVM controller. In contrast, hardware solutions generally require extending the cache, the directory,
or the memory controller to automate logging and recovery. They resort to hardware address remapping in the case of 
Copy-on-Write (COW), or hardware store queue in the case of undo logging. The problem with hardware solutions is that
on-chip storage resources are often scarce and have limitations (e.g. access latency, capacity, etc.), which further puts 
a hard limit on the number of concurrent transactions or the maximum read/write sets. When the working set of a transaction
exceeds these hard limits, hardware systems either need to stall to wait for resource, or use software handler as a fall
back path.

Proteus, on the other hand, borrows from both sides and achieves the favorable characteristics of software and hardware 
approaches. Compared with software solutions, Proteus relies on programmers or compilers to mark transaction boundaries
as well as to issue instructions that generate and flushe log entries, when shared data items are updated during a transaction.
Compared with hardware solutions, Proteus similarly extends the processor with a log write queue which stores pending log
entries to be written. In addition, an extra log pending queue is added to the memory controller, such that some log entries 
do not even need to be written to the NVM if the transaction commits before the queue overflows. We elaborate on these designs
in the following sections.

Protus assumes transactional semantics for durable writes: Either all writes within a transaction become durable as the 
transaction commits, or none of them becomes durable, and the transaction is aborted. Special instructions are needed
to begin and attempt to commit a durable transaction. When generating code for a transaction body, compilers are responsible 
for expanding every transactional store instruction to global data items into three instructions: One for reading the old
value and generating the log entry, another for writing data that has been loaded into the cache, and the last for writing
the log entry into NVM logging area. Semantics and implementation of the three instructions will be covered in details. 
Each transaction is allocated a unique transaction ID (TID)