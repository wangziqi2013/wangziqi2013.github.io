---
layout: paper-summary
title:  "ATOM: Atomic Durability in Non-Volatile Memory through Hardware Logging"
date:   2019-02-17 03:52:00 -0500
categories: paper
paper_title: "ATOM: Atomic Durability in Non-Volatile Memory through Hardware Logging"
paper_link: ATOM: Atomic Durability in Non-Volatile Memory through Hardware Logging
paper_keyword: NVM; Undo; ATOM
paper_year: HPCA 2017
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---  

This paper proposes ATOM, an undo-based design for achieving atomic persistency. Atomic persistency is a programming paradigm
in which programmers specify an atomic region, and either all updates within the region are persisted, or none of them is 
persisted, similar to how atomicity is defined for transactions. Atomic persistency is often implemented in software using 
undo logging. Before a data item is written, code must be inserted to copy the old value to an undo log entry if the data 
item is written for the first time in the atomic region. Programmers must also manually issue persistence barriers 
consisting of cache line write back instructions and memory fences to flush log entries and dirty data items back to the 
NVM before the atomic region ends. To guarantee that modifications in the atomic region are able to be rolled back on 
crashes, the undo log entry must be written to the NVM immediately after they are created and before the update is made.
Otherwise, the dirty cache line can be evicted back to the NVM at arbitrary time after it is written, and if this happens
before the log entry reaches NVM, this dirty line cannot be undone during recovery. At the end of the atomic region, software
issues cache line flush instructions to write back all dirty lines. 

This paper identifies two potential performance problems in the software-only scheme. The first problem is that by writing 
the old value into the log and flushing the log entry into the NVM as in undo WAL, data might be read from the NVM just to 
write it back later unmodified, which wastes memory bandwidth. The second problem is that since software has no fine-grained
control over the ordering of NVM write backs, to avoid write ordering violation, the log entry must be written back to the 
NVM right after they are created. During the write back operation, the processor must stall and wait for the operation to
complete, hence putting the slow NVM write back operation on the critical path of execution. In fact, since log entry
write back needs to be done for all store operations on the cache line if the line has not been written since the beginning 
of the atomic region, the processor is unable to overlap memory operations with on-chip computation, which effectively
offsets the performance benefit of modern out-of-order superscalar processors.

ATOM solves the above two issues by extending both the cache controller and memory controller to make them aware of the 
existence of WAL and undo logging. Logging is handled at the hardware level, and therefore the full set of hardware states
are available to support more informative decision making and better utilization of hardware resources. ATOM assumes that
the system consists of cache coherent multicores, and NVM devices connected to the memory bus. Multiple memory controllers
exist to handle memory requests from processors. Each memory controller runs independently based solely on its internal
state, and hence does not constitute a performance bottleneck. DRAM caching is not assumed by this paper. The entire 
address space is mapped to the NVM as is the case with DRAM based system. ATOM performs undo logging in cache line 
granularity. Programmers issue instructions to enter and terminate atomic regions using two instructions that are similar
to hardware transactions. On a failure, it is guaranteed that either modifications in the entire atomic region are preserved,
or none of them are present after recovery.

We describe the operation of ATOM as follows. Each cache line in ATOM is extended with one extra bit, the "logged" bit.
This bit is cleared whenever the processor enters and exits an atomic region, and set when the cache line is written
for the first time. A newly loaded cache line may have this bit set as well depending on the responde from the memory
controller which contains a hint of whether the logged bit is set. On store instructions, if the cache line already exists
in the cache, the logged bit for the line is checked. If the bit is set, then store is committed as usual, because undo
logging only saves the content of the cache line before the first write operation in the atomic region.