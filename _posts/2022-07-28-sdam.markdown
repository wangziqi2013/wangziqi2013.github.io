---
layout: paper-summary
title:  "Software-Defined Address Mapping: A Case on 3D Memory"
date:   2022-07-28 03:51:00 -0500
categories: paper
paper_title: "Software-Defined Address Mapping: A Case on 3D Memory"
paper_link: https://dl.acm.org/doi/10.1145/3503222.3507774
paper_keyword: 3D Memory; HBM; HMC; DRAM; SDAM
paper_year: ASPLOS 2022
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes Software-Defined Address Mapping (SADM), a software-hardware co-design aimed at optimizing 
address mapping for 3D stacked memory.
The paper is motivated by the channel contention problem in high-performance 3D memory introduced by the static 
physical-to-hardware address mapping scheme. 
The paper proposes a virtualized, dynamic address remapping scheme that performs address mapping in the unit of
chunks. The per-chunk address mapping is configurable, such that software components can cluster data with similar
access patterns to the same chunk.
Channel contention is reduced by performing different address mapping for different chunks based on their access 
patterns.

SDM is based on 3D stacked DRAM modules. One of the biggest difference between 3D DRAM and the regular DRAM is 
that the controller has considerably more channels (32 channels), while having much smaller rows (256 bytes).
This property opens the opportunity of Channel-Level Parallelism (CLP), where memory requests are interleaved 
on different channels, such that these requests can be serviced concurrently. 
With all channels working in parallel, 3D DRAM can deliver much higher peak bandwidth than traditional DRAM modules.

Existing 3D DRAM device uses a simple and static address mapping scheme that is initialized at boot time.
Bit slices of physical addresses are used to address channel, bank, and row.
The paper presents an example of existing physical address mapping, where the lower bits are used to address 
channel, the middle bits for bank, and high bits for row.
Such scheme, however, is vulnerable to access patterns that cause channel contention. 
For example, if the channel is addressed by the low 4 bits, then an access stride of 16 will cause all memory requests
to be handled by channel zero, serializing all memory requests, which causes under-utilization and lowers the
throughput.

Prior works leverage CLP in both hardware and software. Hardware approaches monitor the address patterns for memory
requests, and profiles the access pattern using the frequency of bit flips as a metric. 
Bits that flip the most frequently will be used to constitute the channel address, such that consecutive memory
accesses are likely to be mapped to different channels, which maximizes CLP.
