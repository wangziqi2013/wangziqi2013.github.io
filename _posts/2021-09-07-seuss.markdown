---
layout: paper-summary
title:  "SEUSS: Skip Redundant Paths to Make Serverless Fast"
date:   2021-09-07 23:03:00 -0500
categories: paper
paper_title: "SEUSS: Skip Redundant Paths to Make Serverless Fast"
paper_link: https://dl.acm.org/doi/abs/10.1145/3342195.3392698
paper_keyword: Microservice; Serverless; Linux; Process Template
paper_year: EuroSys 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

**Comments:**

1. If you link the unikernel OS with only essential drivers, wouldn't that partially invalidate one of the purposes 
   of microservices, i.e., ease of deployment? Because now you need to tailor the set of device drivers that are 
   necessary for running on different machines.
   This may not be a serious issue for two reasons. First, most serverless performs application-level tasks,
   and general purpose drivers are sufficient. Second, the unikernel is hosted by a QEMU VM, and the VM could
   abstract away part of the hardware differences on different machines.

2. Starting a new process and setting up the interpreter for every new serverless request requires lots of 
   initialization work such as OS-related process initialization and interpreter import and environment setup.
   This paper just proposes that we can start VMM with a pre-initialized image to reduce these overheads.
   While I agree that the interpreter part is definitely not needed anymore, shouldn't the initialization and 
   setup of VMMs, and probably loading these images from I/O devices (or you store them as memory objects?) 
   also require some extra latency? What is the trade-off here? Do we simply assume that the interpreter part
   is the major source of overhead?

This paper proposes SEUSS, a serverless framework that optimizes the long cold-start latency of processes using 
memory snapshots of initialized processes as templates.
The paper is motivated by previous works that attempted to reduce cold-start latency of serverless processes 
by forking an existing process that has already been initialized. The paper argues that the applicability of these 
approaches are limited, as the support for forking existing processes together with the interpreter with all libraries
imported is heavily implementation dependent, and only a few interpreters can achieve that.
The paper addresses the issue by using an unikernel OS as the execution environment of serverless functions.
Process templates are hence saved by taking snapshots of the full memory and execution states of the OS without 
involving the interpreter.

Unikernels are operating system kernels that minimize the number of modules that is included in the runtime image.
Unikernels are typically tailored to the applications that will run on them, and it only contains the system 
services and stacks required by the application. 
In addition, unikernels only support a single address space, and therefore, it runs the best with only one process.
From a different perspective other than the conventional OS-application division, unikernels are just applications
linked with system software and device drivers that are able to execute both user-level and system-level tasks as 
a self-contained unit.
Unikernels are perfect candidate for providing isolation to microservices and serverless, as the kernel image is usually
small, and the time it takes for booting up a unikernel is usually within milliseconds due to its minimum
number of services.

SEUSS uses EbbRT as the underlying unikernel OS. The EbbRT is hosted by a QEMU-based virtual machine, allowing the 
unikernel to run on the bare metal hardware with full system management capabilities (e.g., having its own page 
tables) while providing isolation at the virtual machine layer.
The EbbRT is linked with common scripting environments such as Python and Node.js. Essential device drivers such as
the NIC driver, and software stacks such as user-space TCP-IP are also integrated into the unikernel image.
The paper notes that, although unikernels encourage the usage of application-specific environments, rather 
than the general purpose environment proposed in this paper, it helps to reduce the number of unikernel snapshot 
images and the storage requirement for hosting these images by providing a common base image.

One particularly good thing about combining unikernels and virtual machine is that the full-system image plus the 
contextual states (e.g., register files and other internal processor states) can be easily captured and dumped 
to persistent storage for later use. These snapshots can also be loaded into a fresh virtual machine together with
the execution context to resume execution at the exact point where the snapshot was previously taken.
SEUSS leverages this feature at three different levels. 
