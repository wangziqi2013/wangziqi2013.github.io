---
layout: paper-summary
title:  "In-fat pointer: hardware-assisted tagged-pointer spatial memory safety defense with subobject granularity protection"
date:   2023-01-27 01:36:00 -0500
categories: paper
paper_title: "In-fat pointer: hardware-assisted tagged-pointer spatial memory safety defense with subobject granularity protection"
paper_link: https://dl.acm.org/doi/10.1145/3445814.3446761
paper_keyword: Fat Pointer; Memory Safety
paper_year: ASPLOS 2021
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes In-fat pointer, a hardware pointer tagging scheme that protects applications from spatial
memory errors caused by pointer-related bugs. In-fat pointer leverages the higher unused bits in virtual address 
pointers and embeds object bound and layout information to help specialized hardware check the validity of the 
pointer when the pointers are dereferenced.
Compared to prior works, in-fat pointer achieves a stronger protection guarantee which is at sub-object level 
without incurring high hardware and software overhead.

The paper is motivated by the inefficiencies of prior works. First, some prior works extend the width of a 
regular virtual address pointer to store the extra bits containing the base and bound information of the pointer.
While not limited by the number of usable bits in the upper part of virtual pointers, such a scheme is likely to
increase the application's memory consumption due to wider pointers, and also break backward compatibility at the binary
level because applications compiled to use the legacy interface is unable to be executed under the new model.
Second, some other proposals, most notably AddressSanitizer, adopts a memory-centric approach where metadata is
stored in shadow memory where every address that a pointer can possibly point to is reserved a shadow location
to store the metadata. The shadow memory address of a pointer can then be derived using simple arithmetics.
This design, while retaining the conventional pointer width, consumes an abnormally high amount of memory especially
when the application allocates large arrays. In addition, the amount of memory that needs to be reserved is 
proportional to the size of the working set, rather than to the number of memory allocations.
Lastly, there have also been explorations on tagged-pointer schemes where the metadata bits are embedded in 
the unused higher bits of virtual address pointers. Due to the relatively limited number of bits that can be 
freely repurposed, the metadata bits usually encode a metadata object that is stored somewhere else in the memory,
and the metadata object must be fetched using some complicated addressing schemes.
However, prior works on tagged-pointer designs often only guard memory accesses at the object level without 
considering sub-object level protection as a viable option, which limits the strength of the protection
that they offer.

In-fat pointer addresses the limitations of prior works with two novel features. First, in-fat pointers embrace 
multiple metadata schemes and hence allow the compiler to select the optimal one during compilation time 
according to the static property of the object. Second, in-fat pointers also offer sub-object level protection
that detects spatial memory errors, i.e., if a pointer is generated to point to a non-array field of an
object, the pointer cannot be used to access adjacent fields within the same object.
In-fat pointer is designed to be a tool that assists software debugging and to prevent application bugs. It does not,
however, completely stop malicious attackers from abusing memory bugs as in-fat pointer does not validate the metadata 
bits.
