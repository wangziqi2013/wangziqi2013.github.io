---
layout: paper-summary
title:  "In-fat pointer: hardware-assisted tagged-pointer spatial memory safety defense with subobject granularity protection"
date:   2023-01-27 01:36:00 -0500
categories: paper
paper_title: "In-fat pointer: hardware-assisted tagged-pointer spatial memory safety defense with subobject granularity protection"
paper_link: https://dl.acm.org/doi/10.1145/3445814.3446761
paper_keyword: Fat Pointer; Memory Safety
paper_year: ASPLOS 2021
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes In-fat pointer, a hardware pointer tagging scheme that protects applications from spatial
memory errors caused by pointer-related bugs. In-fat pointer leverages the higher unused bits in virtual address 
pointers and embeds object bound and layout information to help specialized hardware check the validity of the 
pointer when the pointers are dereferenced.
Compared to prior works, in-fat pointer achieves a stronger protection guarantee which is at sub-object level 
without incurring high hardware and software overhead.

The paper is motivated by the inefficiencies of prior works. First, some prior works extend the width of a 
regular virtual address pointer to store the extra bits containing the base and bound information of the pointer.
While not limited by the number of usable bits in the upper part of virtual pointers, such a scheme is likely to
increase the application's memory consumption due to wider pointers, and also break backward compatibility at the binary
level because applications compiled to use the legacy interface is unable to be executed under the new model.
Second, some other proposals, most notably AddressSanitizer, adopts a memory-centric approach where metadata is
stored in shadow memory where every address that a pointer can possibly point to is reserved a shadow location
to store the metadata. The shadow memory address of a pointer can then be derived using simple arithmetics.
This design, while retaining the conventional pointer width, consumes an abnormally high amount of memory especially
when the application allocates large arrays. In addition, the amount of memory that needs to be reserved is 
proportional to the size of the working set, rather than to the number of memory allocations.
