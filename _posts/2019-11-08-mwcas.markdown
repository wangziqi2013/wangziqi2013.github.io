---
layout: paper-summary
title:  "A Practical Multi-Word Compare-And-Swap Operation"
date:   2019-11-08 18:29:00 -0500
categories: paper
paper_title: "A Practical Multi-Word Compare-And-Swap Operation"
paper_link: https://dl.acm.org/citation.cfm?id=676137
paper_keyword: MWCAS
paper_year: DISC 2002
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents an algorithm for implementing Multi-Word Compare-and-Swap (MWCAS). MWCAS is useful as a basic primitive 
in constructing lock-free algorithms, as an enhancement to the already-present single word CAS on most platforms. Compared
with previous proposals, this paper's MWCAS implementation has the following features that make it attractive to data
structure designers. First, this paper's design is non-blocking, which means that threads will always make progress by
helping each other when they observe a partially finished MVCAS. This can help avoid certain pathologies with lock-based
programming. Second, MVCAS in this paper is disjoint-access-parallel (D-A Parallel), meaning that accesses on disjoint data
can proceed in parallel with blocking each other. This avoids unnecessary serialization of operations when they are not 
operating on the same data items. Third, the MWCAS requires no extra metadata except a pool of descriptors, and only reserves 
a few bits per word. This makes it generally applicable to pointer-based data structures as most pointers nowadays have 
a few redundant bits that can be used to hold the metadata. Lastly, the MWCAS design only relies on a single hardware primitive,
Compare-and-Swap, which makes it portable among different architectures.

The MWCAS algorithm is based on a more basic primitive, restricted double compare and single swap (RDCSS). RDCSS is an atomic
primitive that checks two locations for expected values, and swaps the second location with the new value if the comparison
results in success. Otherwise, the location is not updated as if the operation has not been executed. RDCSS can be expressed
in C language in the following way:

```C
uint64_t RDCSS(uint64_t *a1, uint64_t *a2, uint64_t o1, uint64_t o2, uint64_t n2) {
  uint64_t a2_local = *a2;
  if(*a1 == o1 && a2_local == o2) *a2 = n2;
  return a2_local;
}
```

This procedure, however, is non-atomic. Imagine what will happen if another thread writes a1 and reads a2 after the "if"
condition check, and after the branch is executed (assuming that the condition is true). In this case, the RDCSS sequence 
is serialized before the "write a1" operation by not observing its update, and in the meantime serialized after "read a2"
by overwriting the value it just observed. This implies that the RDCSS sequence must not be atomic, since otherwise, the 
atomic point will be both before "write a1" and "read a2", which is impossible, since "write a1" happens before "read a2"
in the program order.