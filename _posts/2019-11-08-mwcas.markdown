---
layout: paper-summary
title:  "A Practical Multi-Word Compare-And-Swap Operation"
date:   2019-11-08 18:29:00 -0500
categories: paper
paper_title: "A Practical Multi-Word Compare-And-Swap Operation"
paper_link: https://dl.acm.org/citation.cfm?id=676137
paper_keyword: MWCAS
paper_year: DISC 2002
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents an algorithm for implementing Multi-Word Compare-and-Swap (MWCAS). MWCAS is useful as a basic primitive 
in constructing lock-free algorithms, as an enhancement to the already-present single word CAS on most platforms. Compared
with previous proposals, this paper's MWCAS implementation has the following features that make it attractive to data
structure designers. First, this paper's design is non-blocking, which means that threads will always make progress by
helping each other when they observe a partially finished MVCAS. This can help avoid certain pathologies with lock-based
programming. Second, MVCAS in this paper is disjoint-access-parallel (D-A Parallel), meaning that accesses on disjoint data
can proceed in parallel with blocking each other. This avoids unnecessary serialization of operations when they are not 
operating on the same data items. Third, the MWCAS requires no extra metadata except a pool of descriptors, and only reserves 
a few bits per word. This makes it generally applicable to pointer-based data structures as most pointers nowadays have 
a few redundant bits that can be used to hold the metadata. Lastly, the MWCAS design only relies on a single hardware primitive,
Compare-and-Swap, which makes it portable among different architectures.

The MWCAS algorithm is based on a more basic primitive, restricted double compare and single swap (RDCSS). RDCSS is an atomic
primitive that checks two locations for expected values, and swaps the second location with the new value if the comparison
results in success. Otherwise, the location is not updated as if the operation has not been executed. RDCSS can be expressed
in C language in the following way:

```C
uint64_t RDCSS(uint64_t *a1, uint64_t *a2, uint64_t o1, uint64_t o2, uint64_t n2) {
  uint64_t a2_local = *a2;
  if(*a1 == o1 && a2_local == o2) *a2 = n2;
  return a2_local;
}
```

This procedure, however, is non-atomic. Imagine what will happen if another thread writes a1 and reads a2 after the "if"
condition check, and after the branch is executed (assuming that the condition is true). In this case, the RDCSS sequence 
is serialized before the "write a1" operation by not observing its update, and in the meantime serialized after "read a2"
by overwriting the value it just observed. This implies that the RDCSS sequence must not be atomic, since otherwise, the 
atomic point will be both before "write a1" and "read a2", which is impossible, since "write a1" happens before "read a2"
in the program order. In other words, the other thread executing the write and read on a1, a2 observes partially updated 
state by the RDCSS function (such observation does not necessarily involve reading a value; writing into its read set is
also an implicit way of synchronization, i.e. anti-dependency), which violates the definition of atomicity.

To ensure atomicity of RDCSS, we may use an existing algorithm, Two-Phase Locking, that generally works for any read-write 
sequence. The 2PL scheme works by acquiring locks before accessing (reading and/writing) data items. The access must be
wrapped between the lock and unlock pair. One additional requirement of 2PL is that once the thread starts releasing a 
lock, no new lock shall be acquired. We prove the atomicity of 2PL by contradiction. Assume another transaction T2 is 
serialized both before and after the 2PL transaction T1. Then it must be serialized both before and after the transaction 
by any of the RAW, WAR or WAW. We can then deduce that the transaction T2 must have accessed a data item A before T1 does,
and another data item B (which can be the same item or a different one) after T1 does. According to the locking principle,
if T2 accesses A, and T1 accesses it later, then it must be that T2 releases the lock on A, and T1 acquires the lock. 
We can then deduce that before T1 accesses A, T2 must have already entered the shrinking phase of 2PL. If we look at the after
sequence, however, T2 accessed B after T1 does. This implies that when T1 accesses B, it is unlocked, since otherwise
T1 will have to wait for the lock. Then we know that T2 acquired the lock on B at some time point after T1 accesses B.
We have the following ordering: 

(1) T2 unlock A < T1 lock A < T1 access A < T1 unlock A; 

(2) T1 lock B < T1 access B < T1 unlock B < T2 lock B. 

Since T1 obeys 2PL protocol, which demands that T1 must not lock any item after any item is unlocked, we know that 
T1 lock A must happen before T1 unlock B, and here concludes out proof, since by adding T1 lock A < T1 unlock B,
we have derived T2 unlock A < T2 lock B, which violates the 2PL rule that no lock release shall happen before a lock
acquisition. A contradiction!

By proving that 2PL is correct, we now can rewrite the RDCSS in the following manner:

```C
uint64_t RDCSS(uint64_t *a1, uint64_t *a2, uint64_t o1, uint64_t o2, uint64_t n2) {
  lock(a2);
  uint64_t a2_local = *a2;  // Access protected by lock on a2
  lock(a1);
  uint64_t a1_local = *a1;  // Access protected by lock on a1
  unlock(a1);
  if(a1_local == o1 && a2_local == o2) *a2 = n2; // Protected by lock on a2
  unlock(a2);
  return a2_local;
}
```

Correspondingly, all reads and writes to address a1 and a2 must be synchronized using the same locks on both addresses.
Since 2PL guarantees atomicity of transactions, the implementation of RDCSS is atomic.

Using locks solves the correctness problem, but has a large performance overhead, due to the fact that locks are not 
scalable in a multicore environment. The algorithm seeks to optimize this base algorithm as follows. First, the lock
and unlock around a1 read can be removed, given that reading a single word is always atomic (which is always the case
on x86 for word aligned read). This lock-unlock pair is unnecessary, since any operation can still occur right before
and after the lock and unlock, respectively, which cannot be distinguished by the version with lock (i.e. write a2, lock a2,
read a2, unlock a2 is exactly the same as write a2, read a2; Similar reasoning applies to writing a2 after unlocking it).
