---
layout: paper-summary
title:  "Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming"
date:   2023-02-07 23:20:00 -0500
categories: paper
paper_title: "Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming"
paper_link: https://dl.acm.org/doi/10.1145/2815400.2815406
paper_keyword: RCU; RLU; STM; Read-Log-Update
paper_year: SOSP 2015
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Read-Log-Update (RLU), a parallel programming paradigm that replaces Read-Copy-Update (RCU)
as a lightweight synchronization primitive. RLU overcomes the limitations of RCU by providing a higher
degree of writer parallelism and better flexibility. To achieve this goal, RLU adopted the timestamp-based 
synchronization algorithm from Software Transactional Memory (STM) designs and tailored it for the specific
challenge that RLU aims to address. Compared with RCU, RLU demonstrates higher operation throughput and better
scalability on certain commonly used data structures, which proves to be a feasible alternative to RCU for 
manipulating concurrent data structures. 

RCU is a lightweight synchronization primitive that has been gaining popularity in Linux kernel for manipulating
pointer-based kernel data structures. Compared with conventional lock-based synchronization primitives, RCU
liberates readers of the data structure from acquiring the lock. Instead, readers can directly access the 
data structure within the declared critical section (using API calls `rcu_read_lock` and `rcu_read_unlock`).
However, for writers, RCU requires that writers must first copy the object it intends to modify into a newly
allocated private object, then apply the writes to the private object, and finally publish the new object to
future readers by atomically switching the pointer that points to the old object to the new one.
In addition, writers must also wait for all readers to give up their reference to the old object after it is unlinked
from the data structure before the old object can be reclaimed.
This process is implemented in the API call `rcu_synchronize`, which waits for all readers, after the time point
it is called, to experience a quiescent period where the reader does not hold any reference to any object in the
structure. The wait time is called a grace period and is essential for the functional correctness of RCU.

The paper identifies three problems with the existing RCU implementation in Linux kernel. First, RCU does not
provide any mechanism to synchronize between writers, and therefore writers must be synchronized via some other 
mechanism such as global spin locks, hence limiting the degree of RCU's parallelism. Second, RCU only supports a 
single pointer switch since the "update" step must be conducted atomically. This constraint greatly limits the 
flexibility of RCU as many common data structures must be updated with multiple pointer swings. For example, in 
Linux kernel, doubly linked lists must only be traversed in one direction if used with RCU to avoid seeing 
inconsistent backward pointers. Lastly, the grace period forces writers to wait for readers, which further degrades
write performance. In addition, as the number of cores increases, the grace period will generally become longer as 
the writer must waiter for every reader core to go through at least one quiescent period.

To address the above problems, the paper proposes RLU which (1) enables multiple writers to proceed as long as they
operate on different data items; (2) allows a writer to commit multiple updates atomically even if these updates 
require more than one pointer swings; and (3) naturally supports the deferral of memory reclamation for unlinked 
objects, hence removing the grace period from the critical path. Overall, RLU is potentially more efficient than RCU
especially on write-dominant workloads due to its higher degree of writer parallelism and lower overhead of 
memory reclamation.

We next describe the design of RLU in more detail. In RLU, every thread has a private log buffer that holds copies 
of shared objects when they are being modified for the first time by the critical section. Objects in the log buffer
will also be published to other readers when the writer completes as we show later. Each shared object has a header
that contains a pointer to the copy of the private object in the log buffer. This pointer is also treated as a lock,
i.e., if the pointer value is NULL, then the object does not have a private copy in the log buffer of one of the 
writers. Consequently, readers can directly access the object without any synchronization.
In order to support atomic commits of multiple written objects, RCU also has a global lock, which is implemented as 
a shared timestamp counter. As we will see later, the counter indicates the current most up-to-date logical snapshot.
Correspondingly, every writer thread also has a writer timestamp, which indicates the snapshot that the writer 
generates. This writer timestamp is initialized to infinity when a thread is created, meaning that the thread does 
not hold any memory snapshot in its private log buffer.
Reader threads, on the other hand, keep a reader timestamp to indicate the memory snapshot it is bound to access. 

Reader threads in RLU delimit the read critical section using the same API as in RCU. At the beginning of the 
read critical section, the thread reads the value of the global timestamp counter and saves it as the read
timestamp. When the reader intends to access
an object, the access wrapper function first reads the pointer value from the object header. If the pointer is NULL,
the reader directly accesses the object as the object is the most up-to-date version.
However, if the pointer is not-NULL, indicating that the object is currently locked by another writer thread, the 
reader thread should then follow the pointer to locate the writer thread (using the log buffer's address) and 
compares its read timestamp with the writer thread's writer timestamp. If the latter is larger, indicating that the
writes happen logically after the reader threads, then the reader thread still accesses the original object. 
This condition also covers the case where the writer thread has infinity as its writer timestamp.
Otherwise, if the reader timestamp is larger, then the reader will read from the writer's private log buffer as the
reader logically starts after the writer commits its modifications.

Writer threads, when they modify an object, they need to first allocate the object in its private log buffer,
and then lock the object by updating its header pointer field. Multiple objects can be modified and added to the log 
buffer, unlike in RCU. In order to lock an object, the locker thread uses atomic Compare-and-Swap instruction to install
the pointer to the private copy in the header field. If locking fails, then the writer should relinquish all previously
locked objects and retry.
After the writer thread completes its critical section, the thread will then atomically commit all its updates
to concurrent and future readers as follows.
First, the writer thread sets its write timestamp to one plus the current global timestamp. 
At this moment, the updates remain invisible to concurrent readers, as these readers will only obtain reader
timestamps that are smaller than the writer timestamp. Next, the writer thread atomically increments the global 
timestamp counter, publishing its writes in the private log buffer to concurrent and future readers.

