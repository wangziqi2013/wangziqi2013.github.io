---
layout: paper-summary
title:  "Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming"
date:   2023-02-07 23:20:00 -0500
categories: paper
paper_title: "Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming"
paper_link: https://dl.acm.org/doi/10.1145/2815400.2815406
paper_keyword: RCU; RLU; STM; Read-Log-Update
paper_year: SOSP 2015
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Read-Log-Update (RLU), a parallel programming paradigm that replaces Read-Copy-Update (RCU)
as a lightweight synchronization primitive. RLU overcomes the limitations of RCU by providing a higher
degree of writer parallelism and better flexibility. To achieve this goal, RLU adopted the timestamp-based 
synchronization algorithm from Software Transactional Memory (STM) designs and tailored it for the specific
challenge that RLU aims to address. Compared with RCU, RLU demonstrates higher operation throughput and better
scalability on certain commonly used data structures, which proves to be a feasible alternative to RCU for 
manipulating concurrent data structures. 

RCU is a lightweight synchronization primitive that has been gaining popularity in Linux kernel for manipulating
pointer-based kernel data structures. Compared with conventional lock-based synchronization primitives, RCU
liberates readers of the data structure from acquiring the lock. Instead, readers can directly access the 
data structure within the declared critical section (using API calls `rcu_read_lock` and `rcu_read_unlock`).
However, for writers, RCU requires that writers must first copy the object it intends to modify into a newly
allocated private object, then apply the writes to the private object, and finally publish the new object to
future readers by atomically switching the pointer that points to the old object to the new one.
In addition, writers must also wait for all readers to give up their reference to the old object after it is unlinked
from the data structure before the old object can be reclaimed.
This process is implemented in the API call `rcu_synchronize`, which waits for all readers, after the time point
it is called, to experience a quiescent period where the reader does not hold any reference to any object in the
structure. The wait time is called a grace period and is essential for the functional correctness of RCU.

The paper identifies three problems with the existing RCU implementation in Linux kernel. First, RCU does not
provide any mechanism to synchronize between writers, and therefore writers must be synchronized via some other 
mechanism such as global spin locks, hence limiting the degree of RCU's parallelism. Second, RCU only supports a 
single pointer switch since the "update" step must be conducted atomically. This constraint greatly limits the 
flexibility of RCU as many common data structures must be updated with multiple pointer swings. For example, in 
Linux kernel, doubly linked lists must only be traversed in one direction if used with RCU to avoid seeing 
inconsistent backward pointers. Lastly, the grace period forces writers to wait for readers, which further degrades
write performance. In addition, as the number of cores increases, the grace period will generally become longer as 
the writer must waiter for every reader core to go through at least one quiescent period.

To address the above problems, the paper proposes RLU which (1) enables multiple writers to proceed as long as they
operate on different data items; (2) allows a writer to commit multiple updates atomically even if these updates 
require more than one pointer swings; and (3) naturally supports the deferral of memory reclamation for unlinked 
objects, hence removing the grace period from the critical path. Overall, RLU is potentially more efficient than RCU
especially on write-dominant workloads due to its higher degree of writer parallelism and lower overhead of 
memory reclamation.

We next describe the design of RLU in more detail. In RLU, every thread has a private log buffer that holds copies 
of shared objects when they are being modified for the first time by the critical section. Objects in the log buffer
will also be published to other readers when the writer completes as we show later. Each shared object has a header
that contains a pointer to the copy of the private object in the log buffer. 
