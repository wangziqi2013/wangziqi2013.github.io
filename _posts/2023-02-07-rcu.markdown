---
layout: paper-summary
title:  "Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming"
date:   2023-02-07 23:20:00 -0500
categories: paper
paper_title: "Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming"
paper_link: https://dl.acm.org/doi/10.1145/2815400.2815406
paper_keyword: RCU; RLU; STM; Read-Log-Update
paper_year: SOSP 2015
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Read-Log-Update (RLU), a parallel programming paradigm that replaces Read-Copy-Update (RCU)
as a lightweight synchronization primitive. RLU overcomes the limitations of RCU by providing a higher
degree of writer parallelism and better flexibility. To achieve this goal, RLU adopted the timestamp-based 
synchronization algorithm from Software Transactional Memory (STM) designs and tailored it for the specific
challenge that RLU aims to address. Compared with RCU, RLU demonstrates higher operation throughput and better
scalability on certain commonly used data structures, which proves to be a feasible alternative to RCU for 
manipulating concurrent data structures. 

RCU is a lightweight synchronization primitive that has been gaining popularity in Linux kernel for manipulating
pointer-based kernel data structures. Compared with conventional lock-based synchronization primitives, RCU
liberates readers of the data structure from acquiring the lock. Instead, readers can directly access the 
data structure within the declared critical section (using API calls `rcu_read_lock` and `rcu_read_unlock`).
However, for writers, RCU requires that writers must first copy the object it intends to modify into a newly
allocated private object, then apply the writes to the private object, and finally publish the new object to
future readers by atomically switching the pointer that points to the old object to the new one.
In addition, writers must also wait for all readers to give up their reference to the old object after it is unlinked
from the data structure before the old object can be reclaimed.
This process is implemented in the API call `rcu_synchronize`, which waits for all readers, after the time point
it is called, to experience a quiescent period where the reader does not hold any reference to any object in the
structure. The wait time is called a grace period and is essential for the functional correctness of RCU.

The paper identifies three problems with the existing RCU implementation in Linux kernel. First, RCU does not
provide any mechanism to synchronize between writers, and therefore writers must be synchronized via some other 
mechanism such as global spin locks, hence limiting the degree of RCU's parallelism. Second, RCU only supports a 
single pointer switch since the "update" step must be conducted atomically. This constraint greatly limits the 
flexibility of RCU as many common data structures must be updated with multiple pointer swings. For example, in 
Linux kernel, doubly linked lists must only be traversed in one direction if used with RCU to avoid seeing 
inconsistent backward pointers. Lastly, the grace period forces writers to wait for readers, which further degrades
write performance. In addition, as the number of cores increase, the grace period will generally become longer as 
the writer must waiter for every reader core to go through at least one quiescent period.
