---
layout: paper-summary
title:  "FaaSM: Lightweight Isolation for Efficient Stateful Serverless Computing"
date:   2021-10-11 00:29:00 -0500
categories: paper
paper_title: "FaaSM: Lightweight Isolation for Efficient Stateful Serverless Computing"
paper_link: https://www.usenix.org/conference/atc20/presentation/shillaker
paper_keyword: Serverless; WebAssembly
paper_year: USENIX ATC 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

**Comments:**

1. I am more interested to learn how multiple faaslets are compiled into the same binary and executed as different 
   threads from WASM, but unfortunately the paper did not discuss this matter. 
   From my perspective (I can be very wrong because I did not know anything about WASM except the most basic concepts),
   WASM programs are compiled into IRs and then code gen into machine code. The memory layout of WASM programs also
   seem to be unable to handle multi-threading. For example, WASM binary has data at the very bottom, followed by 
   stack, followed by the heap. How would the stack be multiplexed between different threads? 
   I am not 100% sure what I said here is correct, so this may just be straightforward to experts and 
   practitioners.

2. Again, a beginner's question: does WASM's binary format follow its abstract memory model? Does the binary image
   in the main memory only occupy a consecutive range of virtual address, with the bottommost being data, then
   stack, then an extendable heap? The paper seems to be suggesting so 
   ("Since WebAssembly memory is represented by a contiguous byte array, containing the stack,heap and data, FAASM 
   restores a snapshot into a new Faaslet using a copy-on-write memory mapping.").

3. The paper spent a major part discussing the OS and storage level interfaces, while leaving many important and
   interesting topics unmentioned. For example, why do you need shared pages between different faaslets? Is it 
   solely to support the local object cache?
   Why faaslets only consume KBs of memory for non-function data? Is it due to page sharing (likely not, because 
   container uses MBs)?
   These questions are either unanswered, or only mentioned briefly without further elaboration.

This paper proposes FaaSM, a language-level software framework for lightweight isolation between serverless functions.
The paper is motivated by the relatively high overhead of OS or hypervisor level resource isolation and the inability
of certain common tasks, such as sharing memory pages and/or file system. 

