---
layout: paper-summary
title:  "Delta pointers: buffer overflow checks without the checks"
date:   2023-02-06 03:05:00 -0500
categories: paper
paper_title: "Delta pointers: buffer overflow checks without the checks"
paper_link: https://dl.acm.org/doi/10.1145/3190508.3190553
paper_keyword: Memory Safety; Delta Pointer; Pointer Tagging
paper_year: EuroSys 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Delta Pointer, a memory safety mechanism that protects the application from buffer overflow attacks.
Delta Pointer aims at providing efficient buffer overflow prevention while minimizing the overhead of software 
instrumentation, especially the branching overhead. To achieve this goal, the Delta Pointer design explicitly embed
the object bound information in the upper bits of the pointer and relies on compiler instrumentation to update
the tag when pointers are generated or moved, but not when pointers are dereferenced. Compared with prior works 
that perform pointer checks when the pointer is dereferenced, Delta Pointers demonstrate less runtime overhead 
on SPEC benchmark due to its ability to remove the explicit bounds check and the branching overhead on pointer
dereferences.

The paper begins by noticing that prior works on software memory protection tend to embed per-object or 
per-type metadata at higher bits of the pointer in order to offer protection. The metadata on the higher bits are 
used to index an in-memory metadata structure that stores the bounds information of the pointer, which is accessed 
by compiler instrumented code when the pointer is dereferenced. While this approach offers functionally correct
protection, they require excessive checks on every pointer dereference. In particular, the paper noted that 
most of them require at least two conditional branches to perform the check, one for the lower bound and the 
the other for the upper bound. Furthermore, certain designs may need more branches to deal with special cases 
such as temporarily out-of-bound pointers and uninstrumented code where the metadata is unavailable. 
These branch instructions are generally expensive operations for modern pipelined processors due to not only 
the execution cycle they occupy but also the complications of branch prediction.

In order to eliminate the conditional branches at pointer dereference time, the Delta Pointer design proposes to
directly embed bounds information on higher unused bits of pointers without any accompanying metadata table
in the main memory. As a result, the embedded metadata must contain all information that is necessary to perform
the check and to support pointer manipulation. In Delta Pointer, the high 32 bits of a 64-bit pointer is dedicated
to storing the metadata, while the lower 32 bits still function as pointers, granting a 4GB address space to the
process. On 64 bit architectures, such a design requires that the binary of the protected process be loaded to
a lower address within the first 4GB of the virtual address space. All the segments of the process, including those
protected by ASLR, must also be moved to the lower address range. Virtual memory range above 4GB and below the kernel
address space should also be reserved with user-space non-reserving mmap calls such that they will not be given out
by the kernel on future mmap calls. On the other hand, the OS address space is unaffected and the kernel can still 
operate with normal 64-bit addressing because Delta Pointer does not instrument the kernel code.

As mentioned earlier, Delta Pointer directly embeds bounds information at the high 32 bits of a pointer.
The metadata is initialized by compiler-generated instrumentation when a new object is allocated and a pointer 
is generated from the object.
The middle 31 bits of the pointer is initialized to be the negation of object size in two's complement form,
while the highest bits of the pointer is reserved to indicate the validity of the pointer.
When a pointer is moved via pointer arithmetic, the compiler also generates code to add or subtract the
same value from the tag as is for the pointer.

