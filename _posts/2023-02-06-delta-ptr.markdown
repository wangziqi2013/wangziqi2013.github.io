---
layout: paper-summary
title:  "Delta pointers: buffer overflow checks without the checks"
date:   2023-02-06 03:05:00 -0500
categories: paper
paper_title: "Delta pointers: buffer overflow checks without the checks"
paper_link: https://dl.acm.org/doi/10.1145/3190508.3190553
paper_keyword: Memory Safety; Delta Pointer; Pointer Tagging
paper_year: EuroSys 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Delta Pointer, a memory safety mechanism that protects the application from buffer overflow attacks.
Delta Pointer aims at providing efficient buffer overflow prevention while minimizing the overhead of software 
instrumentation, especially the branching overhead. To achieve this goal, the Delta Pointer design explicitly embed
the object bound information in the upper bits of the pointer and relies on compiler instrumentation to update
the tag when pointers are generated or moved, but not when pointers are dereferenced. Compared with prior works 
that perform pointer checks when the pointer is dereferenced, Delta Pointers demonstrate less runtime overhead 
on SPEC benchmark due to its ability to remove the explicit bounds check and the branching overhead on pointer
dereferences.

The paper begins by noticing that prior works on software memory protection tend to embed per-object or 
per-type metadata at higher bits of the pointer in order to offer protection. The metadata on the higher bits are 
used to index an in-memory metadata structure that stores the bounds information of the pointer, which is accessed 
by compiler instrumented code when the pointer is dereferenced. While this approach offers functionally correct
protection, they require excessive checks on every pointer dereference. In particular, the paper noted that 
most of them require at least two conditional branches to perform the check, one for the lower bound and the 
the other for the upper bound. Furthermore, certain designs may need more branches to deal with special cases 
such as temporarily out-of-bound pointers and uninstrumented code where the metadata is unavailable. 
These branch instructions are generally expensive operations for modern pipelined processors due to not only 
the execution cycle they occupy but also the complications of branch prediction.

In order to eliminate the conditional branches at pointer dereference time, the Delta Pointer design proposes to
directly embed bounds information on higher unused bits of pointers without any accompanying metadata table
in the main memory. As a result, the embedded metadata must contain all information that is necessary to perform
the check and to support pointer manipulation. In Delta Pointer, the high 32 bits of a 64-bit pointer is dedicated
to storing the metadata, while the lower 32 bits still function as pointers, granting a 4GB address space to the
process. On 64 bit architectures, such a design requires that the binary of the protected process be loaded to
a lower address within the first 4GB of the virtual address space. All the segments of the process, including those
protected by ASLR, must also be moved to the lower address range. 
