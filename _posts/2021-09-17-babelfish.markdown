---
layout: paper-summary
title:  "BabelFish: Fuse Address Translation for Containers"
date:   2021-09-17 23:52:00 -0500
categories: paper
paper_title: "BabelFish: Fuse Address Translation for Containers"
paper_link: https://dl.acm.org/doi/10.1109/ISCA45697.2020.00049
paper_keyword: Virtual Memory; Linux; Paging; MMU; Containers; BabelFish
paper_year: ISCA 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
--- 

**Comments:**

1. In the base version (without the PC bit mask), do you assume that the TLB set index is generated solely with the
   lower bits of VA? Or it is generated by a function taking both VA and ASID/CCID?
   I am asking this, because if it is the former case, then all entries with the same VA will be mapped to the same 
   set, which sounds very unlikely because this causes unnecessary set conflicts. In the latter case,
   the lookup latency can potentially be doubled, because the set index using ASID and CCID can be different.
   Two probes must be made in this case, CCID first, and ASID later if the previous one misses.

2. The above issue is even more prominent in the version with PC bit mask, because if a process shares the same 
   CCID with other processes, but it has a private entry, then the first lookup must be performed using CCID and the
   VA to generate the index, which will hit the entry, and the PC mask will be checked. Only at this moment can we
   know that the VA has a private entry, and the second probe is performed using ASID and the VA
   
3. Where are the "O" bits stored? Are they stored in the page table entries and loaded by the page walker just
   like other permission bits? 
   Where are the CCID field stored? In the page table? What if there are not sufficient number of vacant bits
   in the current Intel PTE?
   Obviously software has no way to set the O bit or the CCID field in the TLB, as the TLB lookup and page walk are 
   fully controlled by the MMU.

4. Is it a hard requirement that all processes sharing translation entries must use the same page table?
   I guess it is positive, because otherwise, the TLB may fetch redundant entries with different ASIDs but
   identical VAs, in which case it also needs to identify redundant entries and merge them.

This paper proposes BabelFish, a virtual memory optimization that aims at reducing duplicated TLB entries and page 
table entries. BabelFish is motived by the fact that containerized processes often share physical pages and the
corresponding address mappings. On current TLB architectures, these mappings will be cached by the TLB as distinct
entries, because of the ASID field for eliminating homonym or expensive TLB flushes on context switches.
BabelFish reduces the degree of redundancy in both TLB caching and page table entries in the main memory by allowing 
single TLB entries and single page table entries to be shared across processes, with probable exceptions tracked
by additional metadata structures. 

Container is a lightweight mechanism for isolating processes running in the same OS, which has drawn an increasing 
amount of interest in microservice and serverless due to its faster loading time compared with virtual machines.
Each containerized process may have its own namespaces and illusion of exclusive ownership to resources such as 
CPU, memory, and the file system. Processes in containers are, in fact, still Linux processes, and have their own 
address spaces with virtual-to-physical mapping. 
The paper observes that containerized processes typically have many identical VA to PA mappings and permission bits 
despite that they are actually in different address spaces. The paper identifies several factors that contribute to 
this observation.
First, in microservice and serverless architectures, the number of service instances are adjusted based on the dynamic 
load, and it is common that many instances of the same service are started to handle requests. All of the instances
share the same underlying binary and the libraries, which are also usually mapped to the same virtual address at each
process.
Second, the paper claims that container processes are created with the fork() system call, which produces a child 
process sharing the VA to PA mapping of the parent process in a Copy-on-Write (CoW) manner. Many pages will not
be CoW'ed, and remains being shared and read-only between the two processes, which are also at the same virtual
address and mapped to the same physical address.
Third, these processes can map certain shared files to the address using mmap() and MAP_SHARED flag, meaning that the
content of the file is mapped to the address space and is backed by the same physical pages. If mmap() picks the 
same virtual address for the mapping, all sharers will also observe the same VA to PA translation entries.
Lastly, cloud providers who is responsible for maintaining the containerized environments may also add their own
middleware for container management and pricing. The code and data of the middleware can also be shared by all 
processes.

BabelFish assumes a two-level TLB architecture, in which each entry consists of at least the VA, which is used as the
lookup key, the PA, a set of permission bits, and an ASID field to distinguish between the entries from different 
processes. The organization of the TLB is orthogonal to the topic. 
The paper also assumes Intel architecture's four-level, radix tree page table, and an MMU that could perform page walks.
A Page Walk Cache (PWC) may also be present to reduce main memory accesses from the page walk by caching the in-memory
translation entries from all levels.

BabelFish works by assigning processes that are likely to share translation entries (e.g., processes fork()'ed from the
same Zygote) with the same CCID (Container Context ID). The CCID of the process is stored in a context register that
is set by the OS on every context switch.
TLB entries are also extended with two extra fields: a CCID field that stores the CCID of the processes that may use
this translation entry, and an Ownership bit indicating whether the page is privately owned by a process, if set, or
shared among processes having the same CCID.
In the base version, the TLB lookup logic is modified as follows. When an entry is under comparison in the middle of
the lookup, the Ownership bit is examined. If the bit is set, then the ASID is compared with the ASID of the current
context (CR3 register value), indicating that the entry is exclusively used by a context. Otherwise, if the 
ownership bit is clear, the CCID field of the entry is compared with the CCID value of the current context.
In either case, a hit is indicated, if both the virtual addresses and the ASID / CCID field match.

The paper also considers the case where a majority of the processes with the same CCID share the same translation
entry, but a small set of processes, with the same CCID, may have their private entries for the same virtual address.
This scenario will occur if a small subset of the processes write to the shared page, and create their own private 
translations due to CoW.
To support this, BabelFish allows a few "exceptions" per entry such that those exceptions will use their private entry
during address translation. The exceptions are marked using a 32-bit "Private Copy (PC)" bit mask per TLB entry, 
and each bit represents whether a process has a private translation. Mapping from processes to bit mask locations 
are tracked by the process context, i.e., by a context register. The bit offset is sent to the TLB lookup logic on 
lookups. During lookup, if a shared entry is hit (Ownership bit is clear), but the PC bit for the process is
set, then the lookup logic still uses the ASID for comparison.

In order to assign processes to PC bits, the OS maintains a separate metadata structure, called MaskPage. This
structure 
