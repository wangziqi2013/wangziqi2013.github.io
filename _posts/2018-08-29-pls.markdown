---
layout: paper-summary
title:  "Predictive Log-Syncrhonization"
date:   2018-08-29 17:48:00 -0500
categories: paper
paper_title: "Predictive Log-Syncrhonization"
paper_link: https://dl.acm.org/ft_gateway.cfm?id=1217965&type=pdf
paper_keyword: Log-Structured; STM; Lock-Free
paper_year: EuroSys 2006
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

Designing concurrent data structure is, in general, a difficult task. For small-scale applications, a single lock that 
blocks access to the entire object suffices. On large-scale data processing platforms with modern multicore architecture,
however, the overhead of inter-thread communication and the bottleneck of blocking render the simple approach unattractive.
Writing efficient concurrent data structures thus require a thorough understanding of the internals of the data structure,
as well as knowing the intrinsic level of parallelism of certain implementations. 

This paper, on the other hand, proposes Predictive Log-Synchronization (PLS) for parallelizing existing serial implementations 
of data structures, without having to fully understand the internals (it helps if one does have a solid understanding). PLS 
extends existing sequential version of a data structure with a log, which records logical operations that worker threads have 
performed. One of the worker threads modifying the data structure periodically acquires a lock before it "replays" the log to 
apply all the pending changes. Other worker threads, while the log is being replayed and the current instance becomes unstable, 
predicts the results of their operations. The prediction process works by reading from a duplicate of the last stable instance, 
and then traversing the read-only log, with the help of a few substate functions. Substate functions apply transformations to
information gathered from the stable instance according to operations performed by all threads. Once the predicting thread finishes
traversing the log, the final result is returned as if it is from the object with all log entries applied. After the log replaying 
thread applies all entries to the instance, an instance switch happens. The instance switch swaps the status of the two instances,
making the one with all log entries applied the stable instance, while the other one writable. This is realized using a global
version counter: the replaying thread increments the counter atomically. Other threads choose the corresponding instance to
read from according to the least significant bit of the version counter.

On initialization, PLS creates two empty instances of the data structure, and sets the version counter to zero. PLS also initializes
two log objects, which are simply arrays of operations which can be traversed from the head to the tail, and inserted at
the tail atomically. Operations are inserted by threads that modify the data structure. One of the two instances is called the 
stable read-only instance, another being called the unstable instance. Each instance is also associated with a spin lock

Operations are categorized into three types: write-only, read-modify-write (RMW), and read-only. 