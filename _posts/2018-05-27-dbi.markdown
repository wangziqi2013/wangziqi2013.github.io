---
layout: paper-summary
title:  "The Dirty-Block Index"
date:   2018-05-27 18:23:00 -0500
categories: paper
paper_title: "The Dirty-Block Index"
paper_link: https://dl.acm.org/citation.cfm?id=2665697
paper_keyword: Dirty Block Index; Cache; Write Back
paper_year: ISCA 2014
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

Several cache system optimizations rely on the dirty bit storage being fast and having 
low latency. This, however, is usually not the case in today's design, where the dirty
bit is part of the tag array. In order to access the array, an index needs to be generated
and is used to activate all tags in the set. This paper proposes an alternative storage format
of dirty bits in a cache. Instead of encoding the dirty bit either with the cache coherence 
state (e.g. "M" state in MESI protocol) or as a separate bit for each element in the set, this 
paper recommends a scheme, called the *Dirty-Block Index* (DBI), which decouples the storage of cache 
sets and dirty bits. The DBI scheme stores dirty bits as an array of tagged entries. Each entry
stores a bit array for a DRAM row. Each bit in the entry represents the dirty status of a cache block
in the row. The tag of the entry encodes the identity of the DRAM row. The entire DBI storage is 
organized as a fully associative cache. The dirty status of a cache line can be located using the 
row address and the cache block offset in a row. 

As DBI decouples the storage of cache tags and dirty bits, information must be maintained in
a consistent manner between the tag store and DBI. The invariant is that a cache line is dirty
*if and only if* there is an entry for the line and the corresponding bit is set. To maintain the 
invariant, when a dirty cache line is evicted, the corresponding entry in the DBI should be cleared
to reflect the change. If all bits in an entry are clear, then the entry itself is freed. Similarly,
when a cache line becomes dirty or a dirty cache line is evicted by higher level caches, the DBI 
should set the bit in the corresponding entry. If the entry does not exist yet, it needs to be 
allocated by the cache controller. If no free entry exists in the DBI, the cache controller evicts 
one entry according to the DBI replacement policy.