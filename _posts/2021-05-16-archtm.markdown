---
layout: paper-summary
title:  "ArchTM: Architecture-Aware, High Performance Transaction for Persistent Memory"
date:   2021-05-16 21:26:00 -0500
categories: paper
paper_title: "ArchTM: Architecture-Aware, High Performance Transaction for Persistent Memory"
paper_link: https://www.usenix.org/system/files/fast21-wu-kai.pdf
paper_keyword: NVM; STM; ArchTM
paper_year: FAST 2021
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents ArchTM, a durable software transactional memory design for byte-addressable non-volatile memory.
The paper is motivated by the discrepancy between previous NVM transactional framework proposals that use emulated or 
simulated NVM device and the actual hardware performance characteristics of commercial NVM device.
Previous designs tend to overestimate write performance and underestimate the write granularity for NVM devices due
to lack of precise information and using throttled DRAM device for emulation.

The actual NVM device, however, demonstrates different characteristics than DRAM in the following way.
First, NVM devices generally sustain much lower write throughput than read throughput. Writing large amount of 
data into the device, therefore, will severely degrade performance.
This discourages putting non-essential metadata on the NVM since metadata will be updated frequently.
Second, NVM devices exhibit optimal performance on multiples of 256B writes. This is caused by its internal
write combining buffer whose size is exactly 256 bytes. Writes belonging to the same 256 byte block will likely
be combined in the buffer, without accessing the physical storage medium.
This implies that application should refrain from writing small data items to randomly addresses; In other words,
NVM devices prefer large and consecutive writes in order to achieve optimal performance.

ArchTM leverages the above observations to achieve better transactional performance.
First, ArchTM adopts shadowing as the persistence protocol for atomic durability. Conventional logging-based
schemes at least doubles the write traffic to the NVM since the same data item must be written twice, once for 
the log, and second time for committed data. Besides, logging requires excessive persist barriers consisting of 
cache line flushes and store fences, which can also degrade performance.
ArchTM, on the contrary, copies an object when it is to be modified within a transaction for the first time, such that
both the old and new version are present. The consistent memory image is still valid as the old object is preserved.
This requires less write traffic and less persist barrier, since only objects modified during a transaction
are flushed at transaction commit point.

Second, ArchTM reduces non-essential and small, random NVM writes by maintaining object-mapping metadata in the DRAM, 
since metadata update may happen far more frequently than data updates, and they usually only write a few words.
The object mapping will be lost during a crash, and rebuilt during recovery by scanning allocated segments, thanks
to the per-object annotation that we discuss later.
Similarly, memory allocator metadata is also maintained in the DRAM. Allocated and free blocks are recognized
during the after-crash scan by reading the annotation on the block header.

Lastly, ArchTM optimizes memory allocation such that small objects are allocated from a single free list,
rather than from several size classes. Despite increased fragmentation when these objects are freed, 
this is justified by the observation that objects allocated together tend to be written together, increasing
the write locality, making it easier for the device to combine writes.
