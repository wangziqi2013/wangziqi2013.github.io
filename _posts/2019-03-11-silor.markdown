---
layout: paper-summary
title:  "Fast Databases with Fast Durability and Recovery Through Multicore Parallelism"
date:   2019-03-11 23:34:00 -0500
categories: paper
paper_title: "Fast Databases with Fast Durability and Recovery Through Multicore Parallelism"
paper_link: https://www.usenix.org/conference/osdi14/technical-sessions/presentation/zheng_wenting
paper_keyword: Database Recovery; Logging; Multicore
paper_year: OSDI 2014
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper presents SiloR, a fast in-memory database system with support for persistence. SiloR is built upon Silo,
an in-memory engine for transaction processing. Silo uses single version Optimistic Concurrency Control (OCC) for
conflict detection. Every tuple in Silo has a version timestamp, consisting of three subfields: Epoch, commit timestamp 
(ct), and status bits. The first two subfields (epoch and ct) of the version timestamp equals the commit timestamp of the 
last write transaction that updates the tuple. A lock bit in the status bit field allows tuples to be locked by a committing 
transaction, providing exclusive access permission for that transaction until commit succeeds. Silo differs from classical 
backward OCC in that it does not rely on a centralized counter for establishing serialization orders. In fact, Silo serializes 
transaction in an entirely distributed and data-driven manner, which prevents scalability problems brought by a centralized 
timestamp counter. Silo keeps track of tuples read and written during the transaction using a read set (RS) and write set 
(WS). At commit time, the transaction manager first locks the write set by acquiring locks for every tuple in the write 
set. The lock acqusition process follows a global total ordering to avoid deadlock. The committing transaction then
reads a global epoch counter, which is advanced slowly only by a background thread (every 40ms). The value of the global 
epoch counter represents the epoch in which the transaction commits. Next, the transaction validates its read by comparing 
versions of tuples in the read against the current tuple version in data tables. If these two versions are different or 
the tuple is currently locked by another committing transaction, indicatingthat another transaction committed (will commit) 
on the tuple after the current transaction reads it, the current transaction must abort. This is because although Silo does 
not use centralized counter to order transactions, the concurrency control procotol is still commit time ordered which 
means that the transaction must ensure that all tuples it accessed must remain unchanged until commit time. If validation 
succeeds, the transaction then proceeds to determine its ct by the following rules. First, the ct must not be smaller than 
or equal to the ct of any tuple in its RS and WS. This guarantees that a tuple's timestamp is monotonically increasing. 
Personally, I don't think ordering the transaction against its read set makes sense, because OCC is, by nature, commit
time ordered. Timestamp assignment does not change the serialization guarantee of the protocol. Second, the ct must not 
be smaller than or equal to the previous ct that the same worker thread has assigned to transactions. This guarantees 
that a single thread will always see monotonically increasing cts. The third rule is that if a transaction committed
in epoch e, then the final version timestamp must also use e. Based on these rules, the committing transaction computes the 
maximum ct over data items in its RS and WS, compare with the last ct, pick the larger one, and then form the version
timestamp using this value and e. The last step of transaction commit it to update data items and version timestamps. 
The transaction first updates tuples using the values in its WS, after which the version timestamp is updated by writing 
the new value into the tuple header. Versions are unlocked after data and metadata are both updated.

Silo commits transactions via group commit, in the notion of consecutive epoches. The global epoch counter E denotes the 
current epoch. Transactions are only committed after the current epoch ends, and log entries for the transaction (as well 
as all other transactions) become durable. The worker thread suspends the transaction if it has finished execution, but 
has not been made persistence. The application is only notified of transaction commit after the epoch that the transaction
is in ends and everything has been persisted to the disk.

