---
layout: paper-summary
title:  "CASPAR: Breaking Serialization in Lock-Free Multicore Synchronization"
date:   2019-10-30 20:19:00 -0500
categories: paper
paper_title: "CASPAR: Breaking Serialization in Lock-Free Multicore Synchronization"
paper_link: https://dl.acm.org/citation.cfm?id=2872400
paper_keyword: CAS; Cache Coherence; CASPAR; Synchronization; Lock-Free
paper_year: ASPLOS 2016
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes CASPAR, a novel cache coherence extension to support efficient serialization based on Compare-And-Swap 
(CAS) primitives. CAS is often used as the synchronization primitive in lock-free programming. Threads access an object 
using a pointer P optimistically, assuming that no interleaving thread will change the state half way during the read. 
Updates are made to the object by creating a new object, and using CAS with the old value of the pointer used to access
the object to atomically swap the new object to the pointer P. The paper identifies that lock-free programs written this
way often suffer from limited scalability for two reasons. First, when the level of contention is high, the CAS is likely
to fail by not observing another thread's intervening update. To deal with such failure, programmers typically use a 
CAS loop to retry the read and update process, which only worsens contention on the variable, since threads will likely 
to spin for multiple rounds before the CAS eventually succeeds. Second, due to the fact that CAS will cause the cache line
holding the variable to be acquired in exclusive ownership, this will essentially serialize the acquisition of the cache
line containing the variable globally. A CAS cannot complete before the previous owner of the cache line finishes CAS
and releases the line. 

This paper proposes a hardware architecture to accelerate CAS execution on directory-based multicore systems. The proposal
relies on the fact that in some commonly used lock-free data structures, such as stacks, queues, etc., the following pattern 
is used to append a new node into the structure. First, a new node is allocated and its content is initialized. The partial
state of this step is not visible to other cores, since this happens in the execution stack of the current thread. Second,
the head pointer of the structure is read into a local variable, H. Thrid, we set the "next" pointer of the newly allocated
node to the value stored in H. In the last step, a CAS is executed using H as the old value and the newly allocated object
as the new value, which (hopefully) adds the new object before the previous object in the head. If an intervening thread
executes its CAS before the current thread does, changing the value of the head pointer, the CAS of the current thread
will fail, which results in one or more retries. 