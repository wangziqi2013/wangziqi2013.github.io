---
layout: paper-summary
title:  "Ribbon: High-Performance Cache Line Flush for Persistent Memory"
date:   2021-07-14 16:05:00 -0500
categories: paper
paper_title: "Ribbon: High-Performance Cache Line Flush for Persistent Memory"
paper_link: https://dl.acm.org/doi/pdf/10.1145/3410463.3414625
paper_keyword: NVM; CLF; Ribbon
paper_year: PACT 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper presents Ribbon, a software framework for optimizing cache line flush (CLF) operations on Non-Volatile 
Memory. Cache line flush operations, or CLFs, are critical in NVM programming, as it controls the order of writes
that are persisted on the NVM device. 
At a semantics level, the CLF instruction evicts a cache block on the given address from the memory hierarchy
and it has global effect (i.e., this instruction is also cache-coherent).
If the cache block is dirty, it will also be written back to the underlying backing store. 
On x86 platform, CLF can take several forms, such as clflush, clflushopt, and clwb. All these three forms are weakly
ordered, meaning that CLF on x86 can be executed in arbitrary order.
In typical usages of CLF, one or more store fence will also be inserted to enforce the ordering that CLFs after the
fence will not be executed until all previous CLFs are completed.

The paper is motivated by the fact that CLFs will significantly affect overall system performance, as enforcement
of write orderings will likely to impose back-pressure to the pipeline, causing pipeline stalls, especially when 
the Write Pending Queue (WPQ) at the memory controller side is full (as it takes longer for the WPQ to accept a 
new write back block).
Besides, the degree of write back parallelism can also negatively impact the throughput of persistence, as too many
threads contending for the WPQ may cause congestion on the memory controller as well as the NoC bus.
On the other hand, if the degree of parallelism is low, the throughput of persistence will not match up with the 
throughput of the device, which is also sub-optimal.
Lastly, the paper also observes that the dirtiness of the block also plays an important role in NVM resource 
utilization. If a cache block is only lightly modified, i.e., most of its contents are unchanged compared with the 
NVM image, writing back an entire block will waste bandwidth as only a small portion of data needs to be updated.

The paper also noted that previous works tend to address these issues by proposing new persistence models and/or new
hardware, which will change the usage model of NVM and is not backward compatible will existing binaries. 
Ribbon, on the contrary, is implemented purely in software, and it is compiled with application source code as a 
library. Ribbon also preserves backward compatibility by requiring only minimum changes to the source code.

From a high level, Ribbon is implemented as a software library that wraps the CLF 
and memory fence primitives. Applications programmers should use these wrappers to invoke Ribbon's instrumentation.
Ribbon also provides an initialization and cleanup function that should be called at the beginning of the application
and at the end of the application, respectively. 
These two functions are responsible for managing data structures and helper threads, as we will see below.

We next discuss Ribbon's optional details. The first feature of Ribbon is CLF decoupling, which decouples CLF
from program execution, allowing them to be completed in the background. 
To achieve this, each user thread is allocated a FIFO CLF buffer for tracking the CLF operations issued from the
thread. 