---
layout: paper-summary
title:  "A Scalable Architecture for Ordered Parallelism"
date:   2019-08-12 17:05:00 -0500
categories: paper
paper_title: "A Scalable Architecture for Ordered Parallelism"
paper_link: A Scalable Architecture for Ordered Parallelism
paper_keyword: Swarm; TLS; HTM; Speculation
paper_year: MICRO 2015
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes Swarm, a highly parallelized architecture supporting Thread-Level Speculation (TLS). This paper 
pointed out that some algorithms intrinsically have abundant parallelism, but most existing speculation mechanisms could 
not exploit them very well for several reasons. First, existing HTM designs are targeted at unordered execution of 
transactional regions. Optimizations such as dirty read are therefore disallowed to maintain isolation, which hinders
concurrency, because if the order of transactions can be known and tracked by hardware in advance, forwarding dirty data
from lower numbered tasks to higher numbers ones are totally legal. Second, speculative tasks are created dynamically
by earlier tasks, usually driven by the structure of the problem itself (e.g. in parallel version of Dijkstra's algorithm,
the creation of tasks are driven by the adjacency structure of nodes). This typically forces the program to be written
in a sequential manner (because there are control dependencies between tasks), which is hard to parallelize without knowing 
the specific problem. Third, unnecessary data dependencies are introduced if we maintain tasks using software structures. 
This happens not only when an explicit task scheduler is implemented, but also in data structures used by the algorithm.
For example, in Dijkstra's algorithm, a priority queue is used to track the distance of candicate nodes from the source.
Any insertion of new nodes into the queue is likely a conflict with some speculative tasks that dequeued a node from 
the queue, but this dependency can be eliminated if hardware can track the structure of task creation. The last 
reason is that existing software solutions can only provide limited performance improvement, while introducing a 
non-negligible overhead, which can offset any improvement gain from parallelization.

Swarm solves the above challenges using a task-based speculation model. Fine-grained pieces of code that can potentially
run in parallel if there is no conflict are abstracted as "tasks". The exection of tasks is expected to have only
a few data dependencies, which will cause the violating task and all its decendants, and related tasks to abort.
Tasks are assigned programmer-defined sequence numbers called timestamps, which specify the logical ordering tasks are 
executed. Swarm guarantees that it appears that tasks are executed sequentially following the partial ordering 
defined by timestmaps. If two or more tasks have the same timestamp, their relative ordering is undefined, and they can 
be executed in any order.