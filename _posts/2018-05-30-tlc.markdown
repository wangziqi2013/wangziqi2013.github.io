---
layout: paper-summary
title: "Maintaining Consistent Transactional States without a Global Clock"
date: 2018-05-30 23:36:00 -0500
categories: paper
paper_title: "Maintaining Consistent Transactional States without a Global Clock"
paper_link: https://link.springer.com/chapter/10.1007%2F978-3-540-69355-0_12
paper_keyword: TL2; STM; Global Clock
paper_year: LNCS 2008
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes a cache friendly implementation of global commit counter commonly
used by software transactional memory designs. Many STM and Hybrid TM algorithm, notably Transactional 
Locking II (TL2) and NORec, relies on a global timestamp counter to either commit events, either 
for individual data items or globally. The most straightforward implementation of the counter is 
to use a 64 bit integer incremented every time a transaction commits. Verification of read 
sets is performed by comparing the value of the counter when the transaction begins and the most up-to-date
value on data items or of the same counter.

Simple as it is, the straightforward implementation does not scale. On today's multicore architecture, 
communication between cores and sockets has become a major source of overhead for memory instructions. Using 
an integer as the global timestamp counter will cause the cache line to be circulated around the cores that
increment and read the cache line. This can greatly increase the latency of memory instructions, and also 
incur contention. This issue has already been recognized in other areas of research, and can be addressed by 
decentralization of the global counter. For example, in epoch-based garbage collection, the global counter which 
counts the number of active threads can be replaced by an array of thread local timestamps that record the last 
time the thread is active. The GC algorithm, instead of collecting garbage memory for epoches whose counter have 
dropped to zero, scans the array of thread local timestamps, and calculates the minimum. Garbage memory freed before
the minimum timestamp can be freed, as no thread can possibly hold a reference to it.
