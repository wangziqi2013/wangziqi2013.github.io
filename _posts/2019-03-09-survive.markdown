---
layout: paper-summary
title:  "Survive: Pointer-Based In-DRAM Incremental Checkpointing for Low-Cost Data Persistence and Rollback-Recovery"
date:   2019-03-09 22:40:00 -0500
categories: paper
paper_title: "Survive: Pointer-Based In-DRAM Incremental Checkpointing for Low-Cost Data Persistence and Rollback-Recovery"
paper_link: https://ieeexplore.ieee.org/document/7801818
paper_keyword: Checkpointing; NVM
paper_year: IEEE Computer Architecture Letters 2017
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes Survive, a memory checkpointing architecture using hybrid NVM and DRAM system. The biggest difference 
between Survive and similar systems is that Survive still runs on DRAM just like a conventional DRAM-only system. NVM is 
deployed as a backend which is invisible to applications and even system libraries. Only during recovery is NVM visible
to a system service called the recovery handler. The paper claims two benefits of such a hybrid system. First, writes to
NVM can be significantly reduced, because most write operations are filtered out by the DRAM. This reduces both the write
latency which is often on the critical path at the end of the checkpoint, and also pressure to the wear leveling mechanism
on the NVM since less writes are actually performed. With careful optimization such as reordering and coalescing, write
amplification can also be alleviated. The second benefit is that hiding NVM behine DRAM allows simpler hardware designs.
There is no need for complicated hardware to enforce proper write ordering, which is a necessity for logging. In addition,
most existing components - coherence protocols, eviction policies, directories, etc. can remain unchanged. This implies 
that no major hardware upgrade is required in order to deploy Survive.

Like many other proposals, Survive adopts an epoch-based recovery paradigm. Normal execution of processors is divided into
epoches. At the end of each epoch, all processors are interrupted to establish a checkpoint, which in general consists of 
three steps. In the first step, processors stall and drain volatile states including the store queue and instruction window.
In the second step, processors evict all dirty cache lines in their local caches back to lower level persistent storage.
In the last step, processors write their execution context including the register file and some on-chip states also
to the persistent storage. After these three steps, a marker is written at the end of the checkpoint, which marks the 
completion of the checkpoint. Normal execution could resume after thrse three steps, which begins a new epoch. During normal
execution, when a data item is written for the first time, an undo log entry is generated which contains the before image
of the cache line. The undo log entry is written into the persistent storage before the updated cache line (some hardware 
is needed to enforce this write ordering). On recovery, the recovery handler first replays the undo log to restore the 
system state to the beginning of one of the recent checkpoints. Note that not all designs allow us to restore the system
state to the most recent checkpoint, because if the persistence of the last checkpoint is overlapped with the execution
of the next few epoches, it is possible that a system crash happens before the most recent checkpoint is fully persisted.
In this case, the only option is to discard the incompleted checkpoint, and use the most recent valid checkpoint for 
recovery. After restoring the system state to the beginning of a checkpoint, the recovery handler then instructs 
all processors to load the execution context, after which the system can resume execution.