---
layout: paper-summary
title:  "Data Locality Exploitation in Cache Compression"
date:   2021-07-05 03:11:00 -0500
categories: paper
paper_title: "Data Locality Exploitation in Cache Compression"
paper_link: https://ieeexplore.ieee.org/document/8644558/
paper_keyword: YACC; DISH; Dual-Block Compression
paper_year: ICPADS 2018
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

**Comments:**

1. The authors may have used "block" and "slot" interchangeably, which is confusing.
   For example, in Section 3.1 it says "Dual-block compression is attempted when multiple
   **blocks** in the same sector are not compressible into a single
   **block**.". I guess the second "block" should be "slot".

This paper proposes Dual-Block Compression, a YACC-based cache compression technique that leverages inter-block 
redundancy for higher compression ratio.
The paper is motivated by a third type of locality: data value locality, in addition to the well-known spatial and
temporal locality. Data value locality suggests that there is a high chance that values in nearby memory locations 
will contain identical or regular values, as a result of loops in the program.
As a result, explicit dictionary-based algorithms (i.e., dictionaries are generated dynamically based on the 
data pattern and co-located with compressed block data, rather than being implicitly encoded in the compressed block) 
work pretty well on these data patterns, since only a few values are sufficient to encode an entire block.
The paper further notices that the pattern can extend across several memory blocks, making it possible to share the 
same dictionary for these blocks. This approach has a clear advantage of avoiding storing multiple dictionary entries
for each block, potentially achieving a higher compression ratio.

The design presented in the paper is based on YACC, a super-block based compressed cache. 
For simplicity of implementation, YACC uses a coupled tag and data array, meaning that each tag entry is statically
mapped to a 64 byte data slot, and data of logical blocks encoded by the tag entry must be stored in the 
corresponding data slot. Cache blocks are compressed before insertion and decompressed before eviction and access.
Each tag entry encodes one to four logical blocks in the same super-block, which consists of four consecutive blocks 
in the physical address space.
The entry only has one address tag, which is aligned to four-block boundaries, and four copies of status bits, such
that each logical block can still function as an independent block.
The index generation function of the cache is skewed, such that all four blocks within the same super-block are mapped
to the same set. 
In addition, there can be multiple tag entries allocated to the same super-block, if the compressed blocks need to be 
stored in more than one data slots.

The original YACC assumes a single-block compression algorithm, and it processes blocks individually without considering
any inter-block redundancy. Previous works such as DICE has explored the design in which multiple blocks in the same
super-block are compressed together using the same dynamic dictionary, leveraging inter-block redundancy as well. 
The dictionary is shared by all blocks currently in the slot (one to four blocks), and it is constructed by scanning 
the blocks for unseen "keys", i.e., 32-bit words that are not in the dictionary.
Data blocks are encoded by storing a pointer to a dictionary entry. Optionally, a small delta can also be stored
with all encoded words. Since the dictionary is small (8 entries), and all code words are of fixed size, decompression
can be pretty fast and complete in just a few cycles.

Dual-block compression improves DICE by observing that, in some workloads, 8 keys are not sufficient to encode all the
distinct values in four blocks. In the experiment, it is also shown that these "hard" workloads actually favor
9 - 24 keys in order to cover all the distinct values.
Increasing the number of entries in the dictionary, however, is impossible for DICE, since the compressed data would
otherwise be significantly larger than 64 bytes.
To deal with this, the paper proposes that, instead of co-locating the dictionary with compressed block in the same
slot, two slots can be used, and one of them stores an uncompressed block in the super-block, which serves both as 
cached data, and as the dictionary for the remaining three blocks. 
The remaining one to three blocks are still encoded in DICE's format, except that each pointer now can refer to 
16 + 8 = 24 entries, and thus thus width of the pointer increases, and are stored in the second slot. 
The eight-entry dictionary in original DICE still co-locates with the other blocks, and it will also be referred
to by compressed code words.
