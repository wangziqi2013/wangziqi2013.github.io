---
layout: paper-summary
title:  "AsymNVM: An efficient Framework for Implementing Persistent Data Structures on Asymmetric NVM Architecture"
date:   2020-08-30 04:46:00 -0500
categories: paper
paper_title: "AsymNVM: An efficient Framework for Implementing Persistent Data Structures on Asymmetric NVM Architecture"
paper_link: https://dl.acm.org/doi/10.1145/3373376.3378511
paper_keyword: NVM; Redo Logging; Semantic Logging; AsymNVM
paper_year: ASPLOS 2020
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper introduces AsymNVM, a distributed shared NVM storage architecture. AsymNVM is motivated by asymmetric NVM architecture,
where NVM storage backends are decoupled from the computation frontend. AsymNVM points out that by decoupling NVM storage node
from the computation node, conventional logging approaches are no longer feasible, due to increased communication
latency. Write ordering, which is essential to logging-based persistence algorithms, requires flushing a cache line to 
the backend NVM, and waiting for the response over the network, taking at least one round-trip delay to complete.

We first describe the asymmetric NVM architecture before presenting details of AsymNVM. The baseline asymmetric NVM
architecture consists of one or more NVM backend and computation frontend. Frontend accesses the NVM devices by 
issuing RDMA commands to explicit retrieve and push data over some high-throughput network, such as Infiniband.
The mapping relation between the frontend and the backend can be arbitrary in order to maximize device utilization.
Both frontend and backend can crash, after which crash recovery will be initiated.
Frontend nodes do not have any NVM device installed. DRAM is available to run the OS and the application, and to
serve as a buffer for data fetched from the backend NVM.
The paper also assumes that the working set can be larger than DRAM capacity at any frontend node, but still within the
capacity limit of the backend, because of higher storage density of NVM compared with DRAM.
As a result, keeping the full volatile working set in the frontend DRAM is not an option, unlike some previous proposals. 
A few mirror nodes are also present as the backup for backend storage. Data is synchronized between the backend nodes
and mirror nodes periodically.

Note that one of the basic assumptions of the paper is that, although the throughput of RDMA is comparable to the 
throughput of NVM devices, the latency of RDMA operations are significantly larger than NVM, which makes it necessary
to design a persistence algorithm that requires less write ordering, as we will see below.

AsymNVM supports a transactional interface, where applications declare transaction boundaries, and the library ensures
that all writes to the NVM are either committed as a unit, or none of them is committed. 
AsymNVM uses a combination of redo logging and semantic logging (operation logging as in the paper) to support both
efficient, low-latency commit, and strong atomicity guarantees, i.e., a transaction is guaranteed to be committed, even 
after crash recovery, after the commit function returns.
The mechanism is described as follows. The backend NVM maintains two log buffers, one is data log buffer, and another 
is semantic log buffer. The data log buffer stores per-line updates as redo entries consisting of the address tag and
cache line data. The semantic log buffer, on the other hand, stores semantic log entries, which describe the operation
with the function name and arguments, if any. 
At transaction begin, 
