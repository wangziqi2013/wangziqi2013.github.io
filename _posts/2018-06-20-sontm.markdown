---
layout: paper-summary
title:  "Hardware Support for Relaxed Concurrency Support In Transactional Memory"
date:   2018-06-20 19:42:00 -0500
categories: paper
paper_title: "Hardware Support for Relaxed Concurrency Support In Transactional Memory"
paper_link: https://ieeexplore.ieee.org/document/5695522/
paper_keyword: HTM; SONTM
paper_year: MICRO 2010
rw_set: Bloom Filter
htm_cd: Incremental FOCC; Lazy BOCC
htm_cr: Eager
version_mgmt: Lazy (Write Log)
---

SONTM is a Hardware Transactional Memory (HTM) design that replicates the well-known interval-based 
OCC which was originally proposed for software implementation. Classical Backward Optimistic Concurrency 
Control (BOCC) protocols introduces false aborts, because they assume read/write conflict as long as 
the read set of a reading transaction has a non-empty intersection with write sets of transactions whose
write phase overlaps with its read phase. In fact, if the reading transaction only reads values after 
the committing transactions have updated them, the schedule should be serializable. In classical OCC,
however, this will be rejected, because the protocol does not track the actual ordering of reads and writes
on data items, and always assumes the worst for safety if the ordering cannot be inferred from the global
commit counter. Second, classical BOCC serializes transactions in the order that they enter the validation
phase. If the directions of actual read/write dependencies differ from the order that transactions enter 
validation, then one of the transactions should be aborted to avoid cyclic dependencies. This may introduce
many artificial aborts, in which case if transactions enter validation phase in a different order, then 
all of them can commit successfully. 

Interval-based OCC was proposed to solve these two problems. In an interval-based OCC design, each data item 
is assigned two timestamps: a write timestamp (WTS) which records the last committed transaction's ID that wrote 
this item; A read timestamp (RTS) which records the last committed transaction's ID that read this item. 
Each transaction has a lower bound (LB) and upper bound (UB), which defines its valid timestamp range that
allows it to serialize with committed transactions. Active transactions serialize with committed transactions 
using the RTS and WTS of data items when they are read and globally written. Transactions read the RTS of read 
data items during the read phase, and the WTS of data items during the validation phase. It then updates its 
own lower bound to be the maximum of RTS in the read set and WTS in the write set. The validation succeeds
if LB is strictly smaller than UB after validation is performed. A commit timestamp, which is also the 
transaction's ID, is chosen from the interval defined by LB and UB. After the interval is chosen, the 
committing transaction broadcasts the commit decision as well as the read and write set to all active transactions. 
On receiving such a commit broadcast, active transactions must set their UB as the broadcasted transaction ID, 
if they have one or more uncommitted reads that are also in the committed write set, or set LB as the transaction 
ID if they have one or more uncommitted writes that are also in the committed read and write set. The last 
step of commit is to update RTS and WTS of data items in the read and write set. The write set is also 
flushed back to global storage. 

SONTM essentially integrates the idea of interval based OCC into the design of transactional memory. Each processor 
is extended with two registers: one for holding the lower bound, and another for upper. The lower bound register is 
initialized to zero, and the upper bound register to the maximum possible value. Read and write sets are kept as 
bloom filters. Write timestamps of every cache line in the system is kept in a hash table, which is stored
in the main memory. The hash table is allocated and managed by system software, and is located on a known location
in the virtual address space (such that each process in the system can have their own transaction context).
Processors retrieve and update the timestamps of any data item in the main memory by calculating its offset
into the hash table, and then read or write the timestamp entry. The hash table may introduce aliasing, where 
multiple addresses are mapped to the same entry and hence share the same write timestamp. We argue that