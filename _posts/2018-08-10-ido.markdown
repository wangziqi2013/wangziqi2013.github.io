---
layout: paper-summary
title:  "iDO: Compiler-Directed Failure Atomicity for Non-Volatile Memory"
date:   2019-08-10 00:19:00 -0500
categories: paper
paper_title: "iDO: Compiler-Directed Failure Atomicity for Non-Volatile Memory"
paper_link: https://ieeexplore.ieee.org/document/8574546
paper_keyword: JUSTDO; iDO; Failure Atomicity; Idempotent Region
paper_year: MICRO 2018
rw_set: 
htm_cd: 
htm_cr: 
version_mgmt: 
---

This paper proposes iDO, a crash recovery scheme based on Non-Volatile Memory using idempotent regions. Classical crash
recovery schemes, such as undo logging, redo logging, and shadow mapping, incur too much overhead by maintaining a runtime
write set and persisting data into the NVM with heavy-weight barriers. A more recent proposal, Justdo Logging, abandons 
per-store logging and data-centric approach of recovery, and instead, relies on the re-execution of the Failure-Atomic
Section (FASE) to reproduce the state before the crash, and furthermore, restore the consistent system state by executing
the FASE till completion. Although Justdo logging may offer better performance because of less persistence barrier, it 
has two constraints which may hinder its practicability. First, Justdo logging assumes a non-volatile cache, which is not 
yet available on today's architecture. Even on future platforms where the cache can be made persistent or be backed 
by a battery, the feasibility of persistent cache is still questionable. Second, Justdo logging requires FASEs be compiled
in a way such that no variable is allocated in the register. To support resumation of execution from an arbitrary point
within the FASE, all memory states must be consistent at the point of crash. If a variable is allocated in the register,
then the most up-to-date value of the variable will be lost, resulting in an invalid snapshot. To enforce this allocation
rule, all variables within a FASE must be declared as volatile, which forces writes to these variables to be conducted 
on the memory address. 

Instead of performing value-based logging, or changing compiler's optimization, iDO leverages the notion of idempotent 
regions. An idempotent region is a one-entry, multiple-exit deterministic code block, the execution of which always 
output the same result given the same input. The general idea is that, if we can divide FASEs into idempotent regions,
then as long as we provide the same input as the ones in normal execution, the final system state will be exactly identical
to the one as if normal execution had not been interrupted. 

This paper assumes that the system is a hybird of NVM and DRAM, with a NVM-specific memory allocation that maps a 
region of memory onto the NVM device. Programmers need to wrap their FASE within a special routine, and all critical
sections of the FASE must be included in the same routine (i.e. no lock held when the routine is called or returns).
It is also assumed that FASEs themselves do not contain software bugs that can cause crash and invoke recovery, because 
the original execution will be replayed during recovery. If the crash is caused by the FASE itself, then during recovery
the same bug will be produced again, which blocks the recovery handler from making any progress.
At initialization time, each thread is allocated a log object, which is organized into a linked list. The recovery 
handler will locate this linked list after a crash. The log object consists of three types of contect information for re-execution 
of an idempotent region. First, all input variables are recorded in the object, including register variables and stack
allocated variables. Second, the program counter of the idempotent region is stored, which is co-located with a flag that
indicates the validity of the log object. When setting this field of a log object, we can also atomically set the validity
bit in the same write (since they are co-located in an 8-byte word), which saves an extra persistence barrier. 
The compiler inserts function calls at the beginning and end of 
idempotent regions. On entering of the first idempotent region in a FASE, the handler function will copy the arguments
and part of the stack frame into the log object for re-execution, and then sets the (), 