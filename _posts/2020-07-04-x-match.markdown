---
layout: paper-summary
title:  "Design and Performance of a Main Memory Hardware Data Compressor"
date:   2020-07-04 16:55:00 -0500
categories: paper
paper_title: "Design and Performance of a Main Memory Hardware Data Compressor"
paper_link: https://ieeexplore.ieee.org/document/546466
paper_keyword: Compression; X-Match; X-RL
paper_year: EUROMICRO 1996
rw_set:
htm_cd:
htm_cr:
version_mgmt:
---

This paper proposes X-Match and X-RL, a memory compression and decompression algorithm with harrware implementation.
The paper identifies three major problems with previous software compression algorithms. First, traditional software
compression algorithms tend to introduce large data blowup at the initial stage of compression, since these algorithms
are designed for streams of large size, while memory compression works on smaller blocks. The second problem is that 
software encoding and decoding are designed to be asynchronous with input and output, meaning that they often consume 
and output bits without a fixed bit rate. Hardware implementations of these algorithms require special interfacing or
buffering with other components, since these hardware components most likely expects the same number of bits per cycle.
The last issue is that most software algorithms are not meant to be mapped to hardware. Their designs more or
less include parts that are not easily transformed into hardware circuits.

From a high level, X-Match is a dictionary-based encoding and decoding scheme using fixed input and output granularity.
The input stream is consumed by compressor in four byte granularity, and the decompressor also outputs data in four byte
granularity. On the compressing side, a dictionary of four byte words are maintained. Words are compared with dictionary
entries to determine whether they can be represented in a shorter form using a combination of dictionary entries and 
raw literals. The results are packed as variably sized codewords consisting of a few fields for identifying the type,
dictionary entry, and/or raw literals. On the decompression side, encoded codewords are consumed field-by-field. 
The decompressor also maintains a dictionary the same way as the compressor, the content of which is a function of 
words that have been compressed/decompressed. The decompressor outputs the original word by combining dictionary entries
with raw literals (if any) in the codeword.

We next describe the compression algorithm in details. As mentioned above, the compressor maintains a dictionary of
four byte words for full and partial matching with incoming words. The size of the dictionary is unspecified. A larger
dictionary may result in better compression for data with distant locality (i.e. symbols tend to repeat on large 
distances), at the cost of using more bits to encode dictionary index. The input word is compared with all dictionary
entries, which may result in full match or partial matches. A full match is the case where all four bytes are identical, 
while in a partial match, two or more bytes at different locations are identical, with the remaining bytes not matching 
the entry. X-Match allows partial mapping to be also encoded using dictionary entries to attain better compression results.
The codeword for a dictionary match is encoded as a "1" bit, followed by the index of the dictionary entry, followed
by the match type, which is then followed by byte literals that are not matched, if any. 




TODO: ADD RUN LENGTH OPTIMIZATION
